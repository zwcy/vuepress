(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{285:function(e,t,r){"use strict";r.r(t),t.default=[{title:"es服务器搭建",path:"/posts/md/part/es/el.html",strippedContent:' ### 启动过程报错    ####  max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]    添加配置 /etc/sysctl.conf (永久性修改)    ```properties  # elasticsearch config start  vm.max_map_count=262144  # elasticsearch config end  ```    > sysctl -p      #### max file descriptors [4096] for elasticsearch process is too low, increase to at least [65535]    添加配置 /etc/security/limits.conf  (永久性修改)    ```properties  # elasticsearch config start  * soft nofile 65536  * hard nofile 131072  * soft nproc 2048  * hard nproc 4096  # elasticsearch config end  ```    重启  elasticsearch.yml    ```yaml  node.name: node-1  cluster.initial_master_nodes: ["node-1"]  ```        `主节点`负责创建索引、删除索引、分配分片、追踪集群中的节点状态等工作    Elasticsearch中的主节点的工作量相对较轻，用户的请求可以发往任何一个节点，由该节点负责分发和返回结果，而不需要经过主节点转发      如果单个node分配多个shard，就会引入另外一系列的性能问题，我们知道对于任意一次完整的搜索，ElasticSearch会分别对每个shard进行查询，最后进行汇总。当节点数和shard数是一对一的时候，所有的查询可以并行运行。但是，对于具有多个shard的节点，如果磁盘是15000RPM或SSD，可能会相对较快，但是这也会存在等待响应的问题，所以通常不推荐一个节点超过2个shard。      但是如果一个小集群，就10个以内的节点，那就所有节点都可以作为master eligible node以及data node即可，超过10个node的集群再单独拆分master和data node吧      如果你的节点数量小于10个，小集群，那所有的node，就不要做额外的配置了，master eligible node，同时也是data node        '},{title:"内存屏障",path:"/posts/md/langu/jdk/memoryBarrier.html",strippedContent:" ### 内存屏障（Memory barrier）  #### 为什么会有内存屏障  - 每个CPU都会有自己的缓存（有的甚至L1,L2,L3），缓存的目的就是为了提高性能，避免每次都要向内存取。但是这样的弊端也很明显：不能实时的和内存发生信息交换，分在不同CPU执行的不同线程对同一个变量的缓存值不同。  - 用volatile关键字修饰变量可以解决上述问题，那么volatile是如何做到这一点的呢？那就是内存屏障，内存屏障是硬件层的概念，不同的硬件平台实现内存屏障的手段并不是一样，java通过屏蔽这些差异，统一由jvm来生成内存屏障的指令。  #### 内存屏障是什么  硬件层的内存屏障分为两种：`Load Barrier` 和 `Store Barrier`即读屏障和写屏障。  内存屏障有两个作用：    阻止屏障两侧的指令重排序；    强制把写缓冲区/高速缓存中的脏数据等写回主内存，让缓存中相应的数据失效。      - 对于Load Barrier来说，在指令前插入Load Barrier，可以让高速缓存中的数据失效，强制从新从主内存加载数据；  - 对于Store Barrier来说，在指令后插入Store Barrier，能让写入缓存中的最新数据更新写入主内存，让其他线程可见。  #### java内存屏障  java的内存屏障通常所谓的四种即LoadLoad,StoreStore,LoadStore,StoreLoad实际上也是上述两种的组合，完成一系列的屏障和数据同步功能。  - LoadLoad屏障：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。  - StoreStore屏障：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。  - LoadStore屏障：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。  - StoreLoad屏障：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能  #### volatile语义中的内存屏障  volatile的内存屏障策略非常严格保守，非常悲观且毫无安全感的心态：  在每个volatile写操作前插入StoreStore屏障，在写操作后插入StoreLoad屏障；  在每个volatile读操作前插入LoadLoad屏障，在读操作后插入LoadStore屏障；    > 由于内存屏障的作用，避免了volatile变量和其它指令重排序、线程之间实现了通信，使得volatile表现出了锁的特性。  #### final语义中的内存屏障  对于final域，编译器和CPU会遵循两个排序规则：  >  新建对象过程中，构造体中对final域的初始化写入和这个对象赋值给其他引用变量，这两个操作不能重排序；（废话嘛）      > 初次读包含final域的对象引用和读取这个final域，这两个操作不能重排序；（晦涩，意思就是先赋值引用，再调用final值）     总之上面规则的意思可以这样理解，必需保证一个对象的所有final域被写入完毕后才能引用和读取。这也是内存屏障的起的作用：  - 写final域：在编译器写final域完毕，构造体结束之前，会插入一个StoreStore屏障，保证前面的对final写入对其他线程/CPU可见，并阻止重排序。  - 读final域：在上述规则2中，两步操作不能重排序的机理就是在读final域前插入了LoadLoad屏障。  X86处理器中，由于CPU不会对写-写操作进行重排序，所以StoreStore屏障会被省略；而X86也不会对逻辑上有先后依赖关系的操作进行重排序，所以LoadLoad也会变省略。  > volatile和final都使用了内存屏障，只不过volatile有两个保障点，可见性和有序性，可见性是通过缓存锁以及缓存一致性协议控制，有序性是内存屏障来保证。"},{title:"AtomicInteger线程安全",path:"/posts/md/langu/mulThread/AtomicInteger%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8.html",strippedContent:" 最近面试被问到一个问题，AtomicInteger如何保证线程安全？我查阅了资料 发现还可以引申到 乐观锁/悲观锁的概念，觉得值得一记。    众所周知，JDK提供了AtomicInteger保证对数字的操作是线程安全的，线程安全我首先想到了synchronized和Lock,但是这种方式又有一个名字，叫做互斥锁，一次只能有一个持有锁的线程进入，再加上还有不同线程争夺锁这个机制，效率比较低，所以又称“悲观锁”。    但是相应的有了乐观锁的概念，他的思路就是，它不加锁去完成某项操作，如果因为冲突失败就重试，直到成功为止。这种说的比较抽象，我们直接拿AtomicInteger源码举例，因为AtomicInteger保证线程安全就是因为使用了乐观锁。    Unsafe 是做一些Java语言不允许但是又十分有用的事情，具体的实现都是native方法，AtomicInteger里调用的 Unsafe 方法 基于的是CPU 的 CAS指令来实现的。所以基于 CAS 的操作可认为是无阻塞的，一个线程的失败或挂起不会引起其它线程也失败或挂起。并且由于 CAS 操作是 CPU 原语，所以性能比较好。  ```java      /**       * Atomically increments by one the current value.       * @return the previous value       */      public final int getAndIncrement() {          return unsafe.getAndAddInt(this, valueOffset, 1);      }  ```  CAS就是Compare and Swap的意思，比较并操作。很多的cpu直接支持CAS指令。CAS是项乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。 从代码上我们可以看到do while语句，从而证实当更新出现冲突时，即失败时，它还会尝试更新。符合乐观锁的思想。    ```java  public final int getAndAddInt(Object var1, long var2, int var4) {          int var5;          do {              var5 = this.getIntVolatile(var1, var2);          } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));          return var5;  }  ```"},{title:"常用解惑",path:"/posts/md/langu/jdk/other.html",strippedContent:" ### for(;;)和while(true)的区别    总结 for(;;) 比 while(true) 好  ```java    编译前              编译后   while (1)         mov eax,1                        test eax,eax                       je foo+23h                      jmp foo+18h  //VS                   编译前              编译后   for (;;)          jmp foo+23h   ```    对比之下，for (；；)指令少，不占用`寄存器`，而且没有判断跳转，比while (1)好。    也就是说两者在在宏观上完全一样的逻辑，但是底层完全不一样，for相对于来说更加简洁明        ------    "},{title:"五笔输入常用500字",path:"/posts/md/other/input/commonWord.html",strippedContent:" 的一是了不在有个人这上中大为来我到出要以时和地们得可下对生也子就过能他会多发说而于自之用年行家方后作成开面事好小心前所道法如进着同经分定都然与本还其当起动已两点从问里主实天高去现长此三将无国全文理明日些看只公等十意正外想间把情者没重相那向知因样学应又手但信关使种见力名二处门并口么先位头回话很再由身入内第平被给次别几月真立新通少机打水果最部何安接报声才体今合性西你放表目加常做己老四件解路更走比总金管光工结提任东原便美及教难世至气神山数利书代直色场变记张必受交非服化求风度太万各算边王什快许连五活思该步海指物则女或完马强言条特命感清带认保望转传儿制干计民白住字它义车像反象题却流且即深近形取往系量论告息让决未花收满每华业南觉电空眼听远师元请容她军士百办语期北林识半夫客战院城候单音台死视领失司亲始极双令改功程爱德复切随李员离轻观青足落叫根怎持精送众影八首包准兴红达早尽故房引火站似找备调断设格消拉照布友整术石展紧据终周式举飞片虽易运笑云建谈界务写钱商乐推注越千微若约英集示呢待坐议乎留称品志黑存六造低江念产刻节尔吃势依图共曾响底装具喜严九况跟罗须显热病证刚治绝群市阳确究久除闻答段官政类黄武七支费父统"},{title:"面试又载在jvm上了",path:"/posts/md/langu/jdk/%E9%9D%A2%E8%AF%95%E5%8F%88%E8%BD%BD%E5%9C%A8jvm%E4%B8%8A%E4%BA%86.html",strippedContent:" 无论什么级别的Java从业者，JVM都是进阶时必须迈过的坎。不管是工作还是面试中，JVM都是必考题。如果不懂JVM的话，薪酬会非常吃亏（近70%的面试者挂在JVM上了）。      掌握了JVM机制，就等于学会了深层次解决问题的方法。对于Java开发者而言，只有熟悉底层虚拟机的运行机制，才能通过JVM日志深入到字节码的层次去分析排查问题，发现隐性的系统缺陷，进而提升系统性能。      一些技术人员开发工具用得很熟练，触及JVM问题时却是模棱两可，甚至连内存模型和内存区域，HotSpot和JVM规范，都混淆不清。工作很长时间，在生产时还在用缺省参数来直接启动，以致系统运行时出现性能、稳定性等问题时束手无措，不知该如何追踪排查。久而久之，这对自己的职业成长是极为不利的。      掌握JVM，是深入Java技术栈的必经之路。    ![jv.png](https://www.mqiy.xyz/image/jvm_outline.png)  "},{title:"环境搭建",path:"/posts/md/part/mid/zookeeper/basicUse.html",strippedContent:" ## Standalone    ###  create it in conf/zoo.cfg:    ```properties  tickTime=2000  dataDir=/var/lib/zookeeper  clientPort=2181  ```        ###  start ZooKeeper  ```shell  bin/zkServer.sh start  ```    ### Connecting to ZooKeeper    ```shell  bin/zkCli.sh -server 127.0.0.1:2181  ```      ## Running Replicated ZooKeeper  For replicated mode, a minimum of three servers are required, and it is strongly recommended that you have an odd number of servers    ### create it in conf/zoo.cfg    ```properties      结点1  tickTime=2000  dataDir=/var/lib/zookeeper  clientPort=2181  initLimit=5  syncLimit=2  server.1=192.168.85.134:2888:3888  server.2=192.168.85.135:2888:3888  server.3=0.0.0.0:2888:3888    echo 1 > /var/lib/zookeeper/myid        结点2  tickTime=200  dataDir=/var/lib/zookeeper  clientPort=2181  initLimit=5  syncLimit=2  server.1=192.168.85.134:2888:3888  server.2=0.0.0.0:2888:3888  server.3=192.168.85.136:2888:3888      echo 2 > /var/lib/zookeeper/myid      结点3  tickTime=2000  dataDir=/var/lib/zookeeper  clientPort=2181  initLimit=5  syncLimit=2  server.1=192.168.85.134:2888:3888  server.2=192.168.85.135:2888:3888  server.3=0.0.0.0:2888:3888      echo 3 > /var/lib/zookeeper/myid  ```    > 注意服务器防火墙是否开启            ####  Cannot open channel to 2 at election address /192.168.85.135:3888    initLimit=5  syncLimit=2  server.1=192.168.85.144:2888:3888  server.2=192.168.85.145:2888:3888  server.3=192.168.85.146:2888:3888        `解决`：   must specify 0.0.0.0 for the current node "},{title:"蚂蚁、头条、拼多多的面试总结",path:"/posts/md/part/interview/2019alipay-pinduoduo-toutiao.html",strippedContent:"\x3c!-- TOC --\x3e  - [写在2019年后的蚂蚁、头条、拼多多的面试总结](#写在2019年后的蚂蚁头条拼多多的面试总结)     - [准备过程](#准备过程)     - [蚂蚁金服](#蚂蚁金服)         - [一面](#一面)         - [二面](#二面)         - [三面](#三面)         - [四面](#四面)         - [五面](#五面)         - [小结](#小结)     - [拼多多](#拼多多)         - [面试前](#面试前)         - [一面](#一面-1)         - [二面](#二面-1)         - [三面](#三面-1)         - [小结](#小结-1)     - [字节跳动](#字节跳动)         - [面试前](#面试前-1)         - [一面](#一面-2)         - [二面](#二面-2)         - [小结](#小结-2)     - [总结](#总结)  \x3c!-- /TOC --\x3e  # 2019年蚂蚁金服、头条、拼多多的面试总结  文章有点长，请耐心看完，绝对有收获！不想听我BB直接进入面试分享：  - 准备过程 - 蚂蚁金服面试分享 - 拼多多面试分享 - 字节跳动面试分享 - 总结  说起来开始进行面试是年前倒数第二周，上午9点，我还在去公司的公交上，突然收到蚂蚁的面试电话，其实算不上真正的面试。面试官只是和我聊了下他们在做的事情（主要是做双十一这里大促的稳定性保障，偏中间件吧），说的很详细，然后和我沟通了下是否有兴趣，我表示有兴趣，后面就收到正式面试的通知，最后没选择去蚂蚁表示抱歉。  当时我自己也准备出去看看机会，顺便看看自己的实力。当时我其实挺纠结的，一方面现在部门也正需要我，还是可以有一番作为的，另一方面觉得近一年来进步缓慢，没有以前飞速进步的成就感了，而且业务和技术偏于稳定，加上自己也属于那种比较懒散的人，骨子里还是希望能够突破现状，持续在技术上有所精进。  在开始正式的总结之前，还是希望各位同仁能否听我继续发泄一会，抱拳！  我翻开自己2018年初立的flag，觉得甚是惭愧。其中就有一条是保持一周写一篇博客，奈何中间因为各种原因没能坚持下去。细细想来，主要是自己没能真正静下来心认真投入到技术的研究和学习，那么为什么会这样？说白了还是因为没有确定目标或者目标不明确，没有目标或者目标不明确都可能导致行动的失败。  那么问题来了，目标是啥？就我而言，短期目标是深入研究某一项技术，比如最近在研究mysql，那么深入研究一定要动手实践并且有所产出，这就够了么？还需要我们能够举一反三，结合实际开发场景想一想日常开发要注意什么，这中间有没有什么坑？可以看出，要进步真的不是一件简单的事，这种反人类的行为需要我们克服自我的弱点，逐渐形成习惯。真正牛逼的人，从不觉得认真学习是一件多么难的事，因为这已经形成了他的习惯，就喝早上起床刷牙洗脸那么自然简单。  扯了那么多，开始进入正题，先后进行了蚂蚁、拼多多和字节跳动的面试。  ## 准备过程  先说说我自己的情况，我2016先在蚂蚁实习了将近三个月，然后去了我现在的老东家，2.5年工作经验，可以说毕业后就一直老老实实在老东家打怪升级，虽说有蚂蚁的实习经历，但是因为时间太短，还是有点虚的。所以面试官看到我简历第一个问题绝对是这样的。  “哇，你在蚂蚁待过，不错啊”，面试官笑嘻嘻地问到。“是的，还好”，我说。“为啥才三个月？”，面试官脸色一沉问到。“哗啦啦解释一通。。。”，我解释道。“哦，原来如此，那我们开始面试吧”，面试官一本正经说到。  尼玛，早知道不写蚂蚁的实习经历了，后面仔细一想，当初写上蚂蚁不就给简历加点料嘛。  言归正传，准备过程其实很早开始了（当然这不是说我工作时老想着跳槽，因为我明白现在的老东家并不是终点，我还需要不断提升），具体可追溯到从蚂蚁离职的时候，当时出来也面了很多公司，没啥大公司，面了大概5家公司，都拿到offer了。  工作之余常常会去额外研究自己感兴趣的技术以及工作用到的技术，力求把原理搞明白，并且会自己实践一把。此外，买了N多书，基本有时间就会去看，补补基础，什么操作系统、数据结构与算法、MySQL、JDK之类的源码，基本都好好温习了（文末会列一下自己看过的书和一些好的资料）。**我深知基础就像“木桶效应”的短板，决定了能装多少水。**  此外，在正式决定看机会之前，我给自己列了一个提纲，主要包括Java要掌握的核心要点，有不懂的就查资料搞懂。我给自己定位还是Java工程师，所以Java体系是一定要做到心中有数的，很多东西没有常年的积累面试的时候很容易露馅，学习要对得起自己，不要骗人。  剩下的就是找平台和内推了，除了蚂蚁，头条和拼多多都是找人内推的，感谢蚂蚁面试官对我的欣赏，以后说不定会去蚂蚁咯😄。  平台：脉脉、GitHub、v2  ## 蚂蚁金服  ![img](https://mmbiz.qpic.cn/mmbiz_jpg/zsXjkGNcic53JMPc0FUw1lBXl5iaibrEXvt9qal7lJSgfGJ8mq00yE1J4UQ9H1oo9t6RAL4T3whhx17TYlj1mjlXA/?wx_fmt=jpeg)  - 一面 - 二面 - 三面 - 四面 - 五面 - 小结  ### 一面  一面就做了一道算法题，要求两小时内完成，给了长度为N的有重复元素的数组，要求输出第10大的数。典型的TopK问题，快排算法搞定。  算法题要注意的是合法性校验、边界条件以及异常的处理。另外，如果要写测试用例，一定要保证测试覆盖场景尽可能全。加上平时刷刷算法题，这种考核应该没问题的。  ### 二面  - 自我介绍下呗 - 开源项目贡献过代码么？（Dubbo提过一个打印accesslog的bug算么） - 目前在部门做什么，业务简单介绍下，内部有哪些系统，作用和交互过程说下 - Dubbo踩过哪些坑，分别是怎么解决的？（说了异常处理时业务异常捕获的问题，自定义了一个异常拦截器） - 开始进入正题，说下你对线程安全的理解（多线程访问同一个对象，如果不需要考虑额外的同步，调用对象的行为就可以获得正确的结果就是线程安全） - 事务有哪些特性？（ACID） - 怎么理解原子性？（同一个事务下，多个操作要么成功要么失败，不存在部分成功或者部分失败的情况） - 乐观锁和悲观锁的区别？（悲观锁假定会发生冲突，访问的时候都要先获得锁，保证同一个时刻只有线程获得锁，读读也会阻塞；乐观锁假设不会发生冲突，只有在提交操作的时候检查是否有冲突）这两种锁在Java和MySQL分别是怎么实现的？（Java乐观锁通过CAS实现，悲观锁通过synchronize实现。mysql乐观锁通过MVCC，也就是版本实现，悲观锁可以通过select... for update加上排它锁）  - HashMap为什么不是线程安全的？（多线程操作无并发控制，顺便说了在扩容的时候多线程访问时会造成死锁，会形成一个环，不过扩容时多线程操作形成环的问题再JDK1.8已经解决，但多线程下使用HashMap还会有一些其他问题比如数据丢失，所以多线程下不应该使用HashMap，而应该使用ConcurrentHashMap）怎么让HashMap变得线程安全？(Collections的synchronize方法包装一个线程安全的Map，或者直接用ConcurrentHashMap)两者的区别是什么？（前者直接在put和get方法加了synchronize同步，后者采用了分段锁以及CAS支持更高的并发） - jdk1.8对ConcurrentHashMap做了哪些优化？（插入的时候如果数组元素使用了红黑树，取消了分段锁设计，synchronize替代了Lock锁）为什么这样优化？（避免冲突严重时链表多长，提高查询效率，时间复杂度从O(N)提高到O(logN)） - redis主从机制了解么？怎么实现的？ - 有过GC调优的经历么？（有点虚，答得不是很好） - 有什么想问的么？  ### 三面  - 简单自我介绍下 - 监控系统怎么做的，分为哪些模块，模块之间怎么交互的？用的什么数据库？（MySQL）使用什么存储引擎，为什么使用InnnoDB？(支持事务、聚簇索引、MVCC) - 订单表有做拆分么，怎么拆的？(垂直拆分和水平拆分) - 水平拆分后查询过程描述下 - 如果落到某个分片的数据很大怎么办？(按照某种规则，比如哈希取模、range，将单张表拆分为多张表) - 哈希取模会有什么问题么？(有的，数据分布不均，扩容缩容相对复杂 ) - 分库分表后怎么解决读写压力？(一主多从、多主多从) - 拆分后主键怎么保证惟一？(UUID、Snowflake算法) - Snowflake生成的ID是全局递增唯一么？(不是，只是全局唯一，单机递增) - 怎么实现全局递增的唯一ID？(讲了TDDL的一次取一批ID，然后再本地慢慢分配的做法) - Mysql的索引结构说下(说了B+树，B+树可以对叶子结点顺序查找，因为叶子结点存放了数据结点且有序) - 主键索引和普通索引的区别(主键索引的叶子结点存放了整行记录，普通索引的叶子结点存放了主键ID，查询的时候需要做一次回表查询)一定要回表查询么？(不一定，当查询的字段刚好是索引的字段或者索引的一部分，就可以不用回表，这也是索引覆盖的原理) - 你们系统目前的瓶颈在哪里？ - 你打算怎么优化？简要说下你的优化思路 - 有什么想问我么？  ### 四面  - 介绍下自己 - 为什么要做逆向？ - 怎么理解微服务？ - 服务治理怎么实现的？(说了限流、压测、监控等模块的实现) - 这个不是中间件做的事么，为什么你们部门做？(当时没有单独的中间件团队，微服务刚搞不久，需要进行监控和性能优化) - 说说Spring的生命周期吧 - 说说GC的过程(说了young gc和full gc的触发条件和回收过程以及对象创建的过程) - CMS GC有什么问题？(并发清除算法，浮动垃圾，短暂停顿) - 怎么避免产生浮动垃圾？(记得有个VM参数设置可以让扫描新生代之前进行一次young gc，但是因为gc是虚拟机自动调度的，所以不保证一定执行。但是还有参数可以让虚拟机强制执行一次young gc) - 强制young gc会有什么问题？(STW停顿时间变长) - 知道G1么？(了解一点 ) - 回收过程是怎么样的？(young gc、并发阶段、混合阶段、full gc，说了Remember Set) - 你提到的Remember Set底层是怎么实现的？ - 有什么想问的么？  ### 五面  五面是HRBP面的，和我提前预约了时间，主要聊了之前在蚂蚁的实习经历、部门在做的事情、职业发展、福利待遇等。阿里面试官确实是具有一票否决权的，很看重你的价值观是否match，一般都比较喜欢皮实的候选人。HR面一定要诚实，不要说谎，只要你说谎HR都会去证实，直接cut了。  - 之前蚂蚁实习三个月怎么不留下来？ - 实习的时候主管是谁？ - 实习做了哪些事情？（尼玛这种也问？） - 你对技术怎么看？平时使用什么技术栈？（阿里HR真的是既当爹又当妈，😂） - 最近有在研究什么东西么 - 你对SRE怎么看 - 对待遇有什么预期么  最后HR还对我说目前稳定性保障部挺缺人的，希望我尽快回复。  ### 小结  蚂蚁面试比较重视基础，所以Java那些基本功一定要扎实。蚂蚁的工作环境还是挺赞的，因为我面的是稳定性保障部门，还有许多单独的小组，什么三年1班，很有青春的感觉。面试官基本水平都比较高，基本都P7以上，除了基础还问了不少架构设计方面的问题，收获还是挺大的。  ## 拼多多  ![img](https://mmbiz.qpic.cn/mmbiz_jpg/zsXjkGNcic53JMPc0FUw1lBXl5iaibrEXvtsmoh9TdJcV0hwnrjtbWPdOacyj2uYe2qaI5jvlGIQHwYtknwnGTibbQ/?wx_fmt=jpeg)  - 面试前 - 一面 - 二面 - 三面 - 小结  ### 面试前  面完蚂蚁后，早就听闻拼多多这个独角兽，决定也去面一把。首先我在脉脉找了一个拼多多的HR，加了微信聊了下，发了简历便开始我的拼多多面试之旅。这里要非常感谢拼多多HR小姐姐，从面试内推到offer确认一直都在帮我，人真的很nice。  ### 一面  - 为啥蚂蚁只待了三个月？没转正？(转正了，解释了一通。。。) - Java中的HashMap、TreeMap解释下？(TreeMap红黑树，有序，HashMap无序，数组+链表) - TreeMap查询写入的时间复杂度多少？(O(logN)) - HashMap多线程有什么问题？(线程安全，死锁)怎么解决？( jdk1.8用了synchronize + CAS，扩容的时候通过CAS检查是否有修改，是则重试)重试会有什么问题么？(CAS（Compare And Swap）是比较和交换，不会导致线程阻塞，但是因为重试是通过自旋实现的，所以仍然会占用CPU时间，还有ABA的问题)怎么解决？(超时，限定自旋的次数，ABA可以通过原理变量AtomicStampedReference解决，原理利用版本号进行比较)超过重试次数如果仍然失败怎么办？(synchronize互斥锁) - CAS和synchronize有什么区别？都用synchronize不行么？(CAS是乐观锁，不需要阻塞，硬件级别实现的原子性；synchronize会阻塞，JVM级别实现的原子性。使用场景不同，线程冲突严重时CAS会造成CPU压力过大，导致吞吐量下降，synchronize的原理是先自旋然后阻塞，线程冲突严重仍然有较高的吞吐量，因为线程都被阻塞了，不会占用CPU ) - 如果要保证线程安全怎么办？(ConcurrentHashMap) - ConcurrentHashMap怎么实现线程安全的？(分段锁) - get需要加锁么，为什么？(不用，volatile关键字) - volatile的作用是什么？(保证内存可见性) - 底层怎么实现的？(说了主内存和工作内存，读写内存屏障，happen-before，并在纸上画了线程交互图) - 在多核CPU下，可见性怎么保证？(思考了一会，总线嗅探技术) - 聊项目，系统之间是怎么交互的？ - 系统并发多少，怎么优化？ - 给我一张纸，画了一个九方格，都填了数字，给一个M*N矩阵，从1开始逆时针打印这M*N个数，要求时间复杂度尽可能低（内心OS：之前貌似碰到过这题，最优解是怎么实现来着）思考中。。。 - 可以先说下你的思路(想起来了，说了什么时候要变换方向的条件，向右、向下、向左、向上，依此循环) - 有什么想问我的？  ### 二面  - 自我介绍下 - 手上还有其他offer么？(拿了蚂蚁的offer) - 部门组织结构是怎样的？(这轮不是技术面么，不过还是老老实实说了) - 系统有哪些模块，每个模块用了哪些技术，数据怎么流转的？（面试官有点秃顶，一看级别就很高）给了我一张纸，我在上面简单画了下系统之间的流转情况 - 链路追踪的信息是怎么传递的？(RpcContext的attachment，说了Span的结构:parentSpanId + curSpanId) - SpanId怎么保证唯一性？(UUID，说了下内部的定制改动) - RpcContext是在什么维度传递的？(线程) - Dubbo的远程调用怎么实现的？(讲了读取配置、拼装url、创建Invoker、服务导出、服务注册以及消费者通过动态代理、filter、获取Invoker列表、负载均衡等过程（哗啦啦讲了10多分钟），我可以喝口水么) - Spring的单例是怎么实现的？(单例注册表) - 为什么要单独实现一个服务治理框架？(说了下内部刚搞微服务不久，主要对服务进行一些监控和性能优化) - 谁主导的？内部还在使用么？  - 逆向有想过怎么做成通用么？ - 有什么想问的么？  ### 三面  二面老大面完后就直接HR面了，主要问了些职业发展、是否有其他offer、以及入职意向等问题，顺便说了下公司的福利待遇等，都比较常规啦。不过要说的是手上有其他offer或者大厂经历会有一定加分。  ### 小结  拼多多的面试流程就简单许多，毕竟是一个成立三年多的公司。面试难度中规中矩，只要基础扎实应该不是问题。但不得不说工作强度很大，开始面试前HR就提前和我确认能否接受这样强度的工作，想来的老铁还是要做好准备  ## 字节跳动  ![img](https://mmbiz.qpic.cn/mmbiz_jpg/zsXjkGNcic53JMPc0FUw1lBXl5iaibrEXvtRoTSCMeUWramk7M4CekxE9ssH5DFGBxmDcw0x9hjzmbIGHVWenDK8w/?wx_fmt=jpeg)  - 面试前 - 一面 - 二面 - 小结  ### 面试前  头条的面试是三家里最专业的，每次面试前有专门的HR和你约时间，确定OK后再进行面试。每次都是通过视频面试，因为都是之前都是电话面或现场面，所以视频面试还是有点不自然。也有人觉得视频面试体验很赞，当然萝卜青菜各有所爱。最坑的二面的时候对方面试官的网络老是掉线，最后很冤枉的挂了（当然有一些点答得不好也是原因之一）。所以还是有点遗憾的。  ### 一面  - 先自我介绍下 - 聊项目，逆向系统是什么意思 - 聊项目，逆向系统用了哪些技术 - 线程池的线程数怎么确定？ - 如果是IO操作为主怎么确定？ - 如果计算型操作又怎么确定？ - Redis熟悉么，了解哪些数据结构?(说了zset) zset底层怎么实现的?(跳表) - 跳表的查询过程是怎么样的，查询和插入的时间复杂度?(说了先从第一层查找，不满足就下沉到第二层找，因为每一层都是有序的，写入和插入的时间复杂度都是O(logN)) - 红黑树了解么，时间复杂度?(说了是N叉平衡树，O(logN)) - 既然两个数据结构时间复杂度都是O(logN)，zset为什么不用红黑树(跳表实现简单，踩坑成本低，红黑树每次插入都要通过旋转以维持平衡，实现复杂) - 点了点头，说下Dubbo的原理?(说了服务注册与发布以及消费者调用的过程)踩过什么坑没有？（说了dubbo异常处理的和打印accesslog的问题） - CAS了解么？（说了CAS的实现）还了解其他同步机制么？（说了synchronize以及两者的区别，一个乐观锁，一个悲观锁） - 那我们做一道题吧，数组A，2*n个元素，n个奇数、n个偶数，设计一个算法，使得数组奇数下标位置放置的都是奇数，偶数下标位置放置的都是偶数 - 先说下你的思路（从0下标开始遍历，如果是奇数下标判断该元素是否奇数，是则跳过，否则从该位置寻找下一个奇数） - 下一个奇数？怎么找？（有点懵逼，思考中。。） - 有思路么？（仍然是先遍历一次数组，并对下标进行判断，如果下标属性和该位置元素不匹配从当前下标的下一个遍历数组元素，然后替换） - 你这样时间复杂度有点高，如果要求O(N)要怎么做（思考一会，答道“定义两个指针，分别从下标0和1开始遍历，遇见奇数位是是偶数和偶数位是奇数就停下，交换内容”） - 时间差不多了，先到这吧。你有什么想问我的？  ### 二面  - 面试官和蔼很多，你先介绍下自己吧 - 你对服务治理怎么理解的？ - 项目中的限流怎么实现的？（Guava ratelimiter，令牌桶算法） - 具体怎么实现的？（要点是固定速率且令牌数有限） - 如果突然很多线程同时请求令牌，有什么问题？（导致很多请求积压，线程阻塞） - 怎么解决呢？（可以把积压的请求放到消息队列，然后异步处理） - 如果不用消息队列怎么解决？（说了RateLimiter预消费的策略） - 分布式追踪的上下文是怎么存储和传递的？（ThreadLocal + spanId，当前节点的spanId作为下个节点的父spanId） - Dubbo的RpcContext是怎么传递的？（ThreadLocal）主线程的ThreadLocal怎么传递到线程池？（说了先在主线程通过ThreadLocal的get方法拿到上下文信息，在线程池创建新的ThreadLocal并把之前获取的上下文信息设置到ThreadLocal中。这里要注意的线程池创建的ThreadLocal要在finally中手动remove，不然会有内存泄漏的问题） - 你说的内存泄漏具体是怎么产生的？（说了ThreadLocal的结构，主要分两种场景：主线程仍然对ThreadLocal有引用和主线程不存在对ThreadLocal的引用。第一种场景因为主线程仍然在运行，所以还是有对ThreadLocal的引用，那么ThreadLocal变量的引用和value是不会被回收的。第二种场景虽然主线程不存在对ThreadLocal的引用，且该引用是弱引用，所以会在gc的时候被回收，但是对用的value不是弱引用，不会被内存回收，仍然会造成内存泄漏） - 线程池的线程是不是必须手动remove才可以回收value？（是的，因为线程池的核心线程是一直存在的，如果不清理，那么核心线程的threadLocals变量会一直持有ThreadLocal变量） - 那你说的内存泄漏是指主线程还是线程池？（主线程 ） - 可是主线程不是都退出了，引用的对象不应该会主动回收么？（面试官和内存泄漏杠上了），沉默了一会。。。 - 那你说下SpringMVC不同用户登录的信息怎么保证线程安全的？（刚才解释的有点懵逼，一下没反应过来，居然回答成锁了。大脑有点晕了，此时已经一个小时过去了，感觉情况不妙。。。） - 这个直接用ThreadLocal不就可以么，你见过SpringMVC有锁实现的代码么？（有点晕菜。。。） - 我们聊聊mysql吧，说下索引结构（说了B+树） - 为什么使用B+树？（ 说了查询效率高，O(logN)，可以充分利用磁盘预读的特性，多叉树，深度小，叶子结点有序且存储数据） - 什么是索引覆盖？（忘记了。。。 ） - Java为什么要设计双亲委派模型？ - 什么时候需要自定义类加载器？ - 我们做一道题吧，手写一个对象池 - 有什么想问我的么？（感觉我很多点都没答好，是不是挂了（结果真的是） ）  ### 小结  头条的面试确实很专业，每次面试官会提前给你发一个视频链接，然后准点开始面试，而且考察的点都比较全。  面试官都有一个特点，会抓住一个值得深入的点或者你没说清楚的点深入下去直到你把这个点讲清楚，不然面试官会觉得你并没有真正理解。二面面试官给了我一点建议，研究技术的时候一定要去研究产生的背景，弄明白在什么场景解决什么特定的问题，其实很多技术内部都是相通的。很诚恳，还是很感谢这位面试官大大。  ## 总结  从年前开始面试到头条面完大概一个多月的时间，真的有点身心俱疲的感觉。最后拿到了拼多多、蚂蚁的offer，还是蛮幸运的。头条的面试对我帮助很大，再次感谢面试官对我的诚恳建议，以及拼多多的HR对我的啰嗦的问题详细解答。  这里要说的是面试前要做好两件事：简历和自我介绍，简历要好好回顾下自己做的一些项目，然后挑几个亮点项目。自我介绍基本每轮面试都有，所以最好提前自己练习下，想好要讲哪些东西，分别怎么讲。此外，简历提到的技术一定是自己深入研究过的，没有深入研究也最好找点资料预热下，不打无准备的仗。  **这些年看过的书**：  《Effective Java》、《现代操作系统》、《TCP/IP详解：卷一》、《代码整洁之道》、《重构》、《Java程序性能优化》、《Spring实战》、《Zookeeper》、《高性能MySQL》、《亿级网站架构核心技术》、《可伸缩服务架构》、《Java编程思想》  说实话这些书很多只看了一部分，我通常会带着问题看书，不然看着看着就睡着了，简直是催眠良药😅。   最后，附一张自己面试前准备的脑图：  链接:https://pan.baidu.com/s/1o2l1tuRakBEP0InKEh4Hzw 密码:300d  全文完。 "},{title:"分布式锁",path:"/posts/md/part/Distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.html",strippedContent:" 三种实现：    - 基于数据库实现分布式锁  - 基于缓存（redis，memcached，tair）实现分布式锁  - 基于Zookeeper实现分布式锁    "},{title:"es介绍",path:"/posts/md/part/es/es%E4%BB%8B%E7%BB%8D.html",strippedContent:" ElasticSearch 是一个`分布式`、`高扩展`、`高实时`的`搜索与数据分析引擎`。它能很方便的使大量数据具有搜索、分析和探索的能力。充分利用ElasticSearch的水平伸缩性，能使数据在生产环境变得更有价值。ElasticSearch 的实现原理主要分为以下几个步骤，首先用户将数据提交到Elastic Search 数据库中，再通过分词控制器去将对应的语句分词，将其权重和分词结果一并存入数据，当用户搜索数据时候，再根据权重将结果排名，打分，再将返回结果呈现给用户。   Elasticsearch是与名为Logstash的数据收集和日志解析引擎以及名为Kibana的分析和可视化平台一起开发的。这三个产品被设计成一个集成解决方案，称为“Elastic Stack”（以前称为“ELK stack”）。   Elasticsearch可以用于搜索各种文档。它提供可扩展的搜索，具有接近实时的搜索，并支持多租户。”Elasticsearch是分布式的，这意味着索引可以被分成分片，每个分片可以有0个或多个副本。每个节点托管一个或多个分片，并充当协调器将操作委托给正确的分片。再平衡和路由是自动完成的。“相关数据通常存储在同一个索引中，该索引由一个或多个主分片和零个或多个复制分片组成。一旦创建了索引，就不能更改主分片的数量。 Elasticsearch使用Lucene，并试图通过JSON和Java API提供其所有特性。它支持facetting和percolating，如果新文档与注册查询匹配，这对于通知非常有用。另一个特性称为“网关”，处理索引的长期持久性；例如，在服务器崩溃的情况下，可以从网关恢复索引。Elasticsearch支持`实时GET`请求，适合作为NoSQL数据存储，但`缺少分布式事务`。    ## 有关概念    - cluster：代表一个[集群](https://baike.baidu.com/item/集群)，集群中有多个节点，其中有一个为主节点，这个主节点是可以通过选举产生的，主从节点是对于集群内部来说的。es的一个概念就是去中心化，字面上理解就是无中心节点，这是对于集群外部来说的，因为从外部来看es集群，在逻辑上是个整体，你与任何一个节点的通信和与整个es集群通信是等价的。 - shards：代表索引分片，es可以把一个完整的索引分成多个分片，这样的好处是可以把一个大的索引拆分成多个，分布到不同的节点上。构成分布式搜索。分片的数量只能在索引创建前指定，并且索引创建后不能更改。 - replicas：代表索引副本，es可以设置多个索引的副本，副本的作用一是提高系统的[容错性](https://baike.baidu.com/item/容错性)，当某个节点某个分片损坏或丢失时可以从副本中恢复。二是提高es的查询效率，es会自动对搜索请求进行负载均衡。 - recovery：代表数据恢复或叫数据重新分布，es在有节点加入或退出时会根据机器的负载对索引分片进行重新分配，挂掉的节点重新启动时也会进行数据恢复。 - river：代表es的一个数据源，也是其它存储方式（如：数据库）同步数据到es的一个方法。它是以插件方式存在的一个es服务，通过读取river中的数据并把它索引到es中，官方的river有couchDB的，RabbitMQ的，Twitter的，Wikipedia的。 - gateway：代表es索引快照的存储方式，es默认是先把索引存放到内存中，当内存满了时再持久化到本地硬盘。gateway对索引快照进行存储，当这个es集群关闭再重新启动时就会从gateway中读取索引备份数据。es支持多种类型的gateway，有本地文件系统（默认），[分布式文件系统](https://baike.baidu.com/item/分布式文件系统)，Hadoop的HDFS和amazon的s3[云存储](https://baike.baidu.com/item/云存储)服务。 - discovery.zen：代表es的自动发现节点机制，es是一个基于p2p的系统，它先通过广播寻找存在的节点，再通过[多播](https://baike.baidu.com/item/多播)协议来进行节点之间的通信，同时也支持[点对点](https://baike.baidu.com/item/点对点)的交互。 - Transport：代表es内部节点或集群与客户端的交互方式，默认内部是使用tcp协议进行交互，同时它支持http协议（json格式）、[thrift](https://baike.baidu.com/item/thrift)、servlet、memcached、zeroMQ等的[传输协议](https://baike.baidu.com/item/传输协议)（通过[插件](https://baike.baidu.com/item/插件)方式集成）。"},{title:"源码",path:"/posts/md/develop/dev.html",strippedContent:" `基础的源码慢慢都啃了一遍 `  - 最基本的HashMap 和 ConcurrentHashMap  - 线程池的源码实现  - 阻塞队列BlockingQueue相关实现  - ReentrantLock 实现，以及其内部同步器Sync的实现原理  - Future的实现原理  - AtomicXXX是如何运转的      看源码的几个好处：    从源码中学习如何性能优化、设计模式等  深入源码，才能了解真相  了解源码，才能更好的解决问题  你懂源码，面试官更懂你  源码怎么读，才比较有效率？    从问题出发，带着问题看源码  面向debug学源码  写写写，做笔记"},{title:"linux常用命令",path:"/posts/md/linux/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html",strippedContent:" #### 搜索文件  find / -name my.cnf         #### 修改文件归属用户与用户组    ```shell   #修改文件归属用户     chown -R hdh elasticsearch-7.3.2      #修改文件归属用户组   chgrp -R hdh elasticsearch-7.3.2    ```    "},{title:"maven",path:"/posts/md/tool/maven.html",strippedContent:" ### run命令    ```shell  java -jar -Dmaven.test.skip=true  ```        ### maven阿里镜像    ```xml  <mirror>      <id>alimaven</id>      <name>aliyun maven</name>      <url>https://maven.aliyun.com/repository/public/</url>      <mirrorOf>central</mirrorOf>            </mirror>   ```            ### Spring Boot 全局排除 spring-boot-starter-logging 依赖    ```xml  \x3c!--全局排除spring-boot-starter-logging内的所有依赖--\x3e  <dependency>      <groupId>org.springframework.boot</groupId>      <artifactId>spring-boot-starter-logging</artifactId>      <exclusions>          <exclusion>              <groupId>*</groupId>              <artifactId>*</artifactId>          </exclusion>      </exclusions>  </dependency>  ```        ### 多模块maven  - 创建项目类型为maven pom的主项目  - 然后分别创建子模块  - 最后在父pom.xml添加子模块，idea成功识别    ```xml      <modules>          <module>spring-boot-admin-server</module>          <module>spring-boot-admin-client</module>      </modules>  ```        ### mvn install resource    ```shell  mvn clean source:jar install  ```"},{title:"不做老好人，你的善良必须要有锋芒",path:"/posts/md/other/%E4%B8%8D%E5%81%9A%E8%80%81%E5%A5%BD%E4%BA%BA%EF%BC%8C%E4%BD%A0%E7%9A%84%E5%96%84%E8%89%AF%E5%BF%85%E9%A1%BB%E8%A6%81%E6%9C%89%E9%94%8B%E8%8A%92.html",strippedContent:" 有一些耋好人，为了周围人的喜欢和认可，不懂拒绝别人，却让自己活得很累，可是别人也不会真的感激你，你为别人付出的时候，别人却不会为你付出，在这样一种不对等的关系中，所以就会产生出让人失望的情绪。很多人不明白，为什么自己替别人做了很多，却得不到应有的回报和尊重呢？而且还会因为稍有一点不满意，别人还会记恨。其实，这其中主要的原因就是因为你太喜欢帮助别人了。      老好人也称为“利他主义者。事实上，利他主义者是用自己的行为在对自己进行操纵——并没有人要求他们这么做！他们的过度付出是造成这种”做了好事却得不到尊重“的情形的元凶。            好人我们都喜欢，但一旦你被别人当成”老好人“，那么你的付出就只会给自己带来无尽的麻烦了。因为，老好人往往给人一种懦弱、没主见的印象。总是表现得很无私，面对别人的种种请求，不管能不能做到，都会硬着头皮允诺，甚至有时候会不惜牺牲自己的利益来帮助他人。      总是毫无怨言地帮别人做事，时间一长，他们会认为你做这些事情是应该的。还有些人是欺软怕硬型的，你总是表现得很弱势，对方会以为你很好”欺负“，所以有什么事情都会想到让你来承担。你帮助他们做一次事情，他们便会让你做更多的事情，因为他们摸准了你不好意思拒绝的弱点。你要知道，只有”雪中送炭“式的帮助才会让人铭记一生，但是如果你随时都会帮助你身边的人做各种事情，那么你很可能会被别人当作傻瓜，或者廉价的劳动力。            老好人的处世原则是宁可自己受委屈也不拒绝别人，但是这样做，却不会被人真正铭记。作为老好人，之所以对他人的要求不愿意轻易拒绝，是担心因为拒绝而使对方难堪，无法保持友好关系。然而，一味地隐忍却不会让对方高看你，相反，还很有可能会越来越瞧不起你。      我们之中大部分人都有欺软怕硬的本质。对于做惯了好人的你，可能要改变自己的秉性的确有些不容易，但是你如果不改变自己的”利他主义“，别人就可能毫无底线地侵犯你。            当然，对于他人的求助，我们不可能袖手旁观，那样的话，我们就太冷血了。但是帮助别人也要遵循一定的原则，要帮助真正有需要帮助和值得帮助的人。如果对方因为懒惰、虚荣、爱占小便宜等原因而让你代劳，那还是果断拒绝吧。此外，对于那些知恩不报，甚至”得了便宜还卖乖“的人，更要保持距离，因为他们是不值得你去付出自己的精力和时间的。            "},{title:"老好人",path:"/posts/md/other/%E8%80%81%E5%A5%BD%E4%BA%BA.html",strippedContent:" `老好人`指的是随和厚道，性格温柔，不愿得罪人，不会拒绝别人，缺乏原则性的人。然而现在社会中普遍反对老好人主义。    ### 心理提示    一直以来，老好人都是以待人热情大方，不会拒绝别人而让你在交际中容易受到大家欢迎，特别是最初阶段。但是，人类都有欺软怕硬心理，在这种心理下，如果你总是习惯性地接受他人的任何请求，常常扮演着一种“老好人”的角色，让人在你身上得寸进尺，那渐渐地你自己也会身心疲惫，早晚有一天会出问题的。  能帮助别人固然很好，但如果总是如此，对方就会得寸进尺，认为你帮忙是理所当然的，感激之情也会淡薄。为了避免这种情况，最好灵活一些，可以偶尔故意拒绝对方的要求。  做人要有自己的尺度，你不是神，也不是大圣人，不可事事做“老好人”，总是对别人谦让，有求必应，这样会让人得寸进尺。  自古以来，什么人都有，恶人，人们恐惧他；善人，人们爱戴他；而那些老好人呢？生活中总是可以看到那些随和厚道的、从不得罪人、看起来似乎没有一点儿脾气儿的，人家什么忙都愿意帮的人。按理来说，这种人应该是最讨人喜欢的，若你遇见了自己不愿意去做的或者懒得去做的事，只要叫一句“某某某，帮我个忙好不好”，一个简单明了的“好”，你就可以潇洒解脱，去做自己喜欢的事情。这多亏了那个热心人啊，怎么着也得给他授予一枚好人勋章吧！可是调查却表明，正是这种不拒绝，也不反抗的人，在“世界上最讨厌的人”排名榜中名列前茅。哎呦，出了力还不得好，为什么会这样呢？    #### 【一、阿伦森效应】  这得归根于有名的阿伦森效应。所谓阿伦森效应，是指伴随奖励减少，态度也逐渐消极；伴随奖励增加，而态度逐渐积极的心理现象。曾经有人做过一个实验，将被试分4组对某一人给予不同的评价，借以观察某人对哪一组最具好感。第一组始终对之褒扬有加，第二组始终对之贬损否定，第三组先褒后贬，第四组先贬后褒，最后在实验对象对数十人进行后，发现大部分人对第四组最具好感，而对第三组最具反感。  阿伦森效应提醒人们，在日常工作与生活中，应该尽力避免由于自己的表现不当所造成的他人对自己印象不良方向的逆转。  老好人在人际交往中吃力不讨好便是这个缘故，当生活的风向改变，他也不得不开口说拒绝。而这唯有的一次拒绝，却比一个贬义词更像是一记巴掌，拍在对方的脸皮上。举例来说吧，有这么一个老好人，第一次，A找他帮忙，他没拒绝；第二次，A又寻求帮助，老好人又帮了他……之后，第三次，第四次，第五次，老好人都毫无意外的帮助A了。但在第无数次的帮忙后，老好人终于因为某些不得已的原因拒绝了A的请求，此时A被激起的愤怒感与失望感将胜于从前的种种，而老好人之前帮A做的所有事情，似乎都在他拒绝A的那一刻起，变得毫无意义。  经过无数次的帮助而建立起来的好感就因为仅有一次的拒绝就被破坏了，这究竟是谁的错？老好人想必也是捶胸顿足，有口难言。可能有人会说“这都是老好人的自作自受，谁让他一直都充当这个老“好人”呢”，但事情远远没有这么简单。    #### 【二、登门槛效应】  很久以前就有人提出了“得寸进尺效应”，也叫做“登门槛效应”，这是指一个人如果接受了别人的一个小要求，那么别人在此基础上再提出一个更高点的要求，这个人也会倾向于接受。  上面所讲的A同志运用的就是得寸进尺效应，因为人的每个意志行动都有其行动的最初目标，在许多场合下，由于人的动机是复杂的，因此常常会面对不同的目标进行比较、衡量和选择，在相同情况下，那些简单易行的目标较容易让人接受并采取行动。另外，人们总愿意把自己调整成前后一贯、首尾一致的形象，即使别人的要求有些过分，但为了维护印象的一贯性，人们也会维持下去。老好人在一开始的时候帮助了A，为了他的美好形象，即使再不情愿，他也会始终的帮助A，所以才会有接踵而来的求助。    #### 【三、摆脱“老好人”的形象】    如何摆脱“老好人”的形象？这个就需要改变你的行为模式。根据吸引力法则，他们会找你帮忙，是因为你是那个“愿意帮忙的人”。  当然，可能有些读者想问，朋友间，总会有不方便、需要帮忙的时候，难道说人家找你帮忙就必须一口拒绝，以免后患吗？我只能说，如果你这么做了，最后倒霉的还是你，你的人际关系和生活最后只会被你的这个“一口拒绝”弄的乱七八糟。对于别人的请求，需要选择性的帮忙，你要戴上辨别是非的眼镜去进行筛选。      #### 【四、选择性帮忙】    如果把你身边的人分成几个生活圈的话，你可以选择：    1. 亲密圈：很好很好的朋友，你和他之间已经不在乎钱的问题，甚至可以分享一切；  2. 朋友圈：身边经常一起玩的，关系不错的，但比亲密圈少一分熟稔的人；  3. 熟人圈：同事、同学，你对他的感觉一般，不热情，不冷淡的；  4. 世界圈：陌生人（调查显示，一个人对陌生人比对认识的人愿意投入更多的信任）。    对于你心目中的亲密圈内的人也不用我说，连钱你都愿意彼此分享了，为他付出，你也定是心甘情愿的；朋友圈里的人，他的人格、人品，他是一个怎样的人，你们经常混在一起，总是略有耳闻的。爱占小便宜的家伙你委婉拒绝他或许是更好的选择，你觉得他还不错的人帮个小忙也无妨。剩下的那些人，你应该切身思考下你的人生会和他有交集吗？你讨厌他什么？仔细衡量其中的利与弊便可瞬间得出结果。  生活是美好的，每个人都是善良的。赠人玫瑰，手留余香。帮助了别人，心里也会快乐。但每个人都是独立的个体，谁也没有义务去无条件地帮谁。与其做一个博爱的滥好人，不如去爱少数人，也为少数人所爱。"},{title:"技术学习网站",path:"/posts/md/",strippedContent:" <https://a870439570.github.io/interview-docs>    <https://github.com/ZXZxin/ZXBlog>    <https://github.com/Snailclimb/JavaGuide>          java成神之路    <https://www.hollischuang.com/archives/3280>    本系列知识出自中华石杉，可以作为互联网 Java 工程师进阶知识完全扫盲    [advanced-java](https://github.com/doocs/advanced-java)        这是一份Java学习指南，涵盖大部分Java程序员所需要掌握的核心知识    [JavaGuide](https://github.com/Snailclimb/JavaGuide)     本项目将LeetCode 上所有的题目都用动画的形式演示出来    [LeetCodeAnimation](https://github.com/MisterBooo/LeetCodeAnimation)           这是一个关于准备面试的项目，该项目包含了九大模块，从算法到操作系统、网络、面向对象以及数据库、Java、分布式、工具、编码实践。    <https://github.com/CyC2018/CS-Notes>        【Java学习+面试指南】 一份涵盖大部分Java程序员所需要掌握的核心知识。    <https://github.com/Snailclimb/JavaGuide>      vi,数据结构，shell学习网站。    <http://c.biancheng.net>         ppt与演讲表达    电脑生成手机代理软件：`fiddler4`  "},{title:"idea",path:"/posts/md/tool/idea.html",strippedContent:" ### Method is never used  ![](https://www.mqiy.cc/843739be-a43d-4663-b15c-e63022487386.png)    #### create serialVersionUID  ![](https://www.mqiy.cc/idea-190417-074849.png)     `shift+tab` ，多行左移    ### 插件  - grep-console      ### 找不到符号  rebuild module"},{title:"压力管理",path:"/posts/md/other/%E5%8E%8B%E5%8A%9B%E7%AE%A1%E7%90%86.html",strippedContent:" 搞定`老婆`和`老板`       情绪不好，`不要做重要的决定`和`接触重要的人`    "},{title:"cap",path:"/posts/md/part/Distributed/cap.html",strippedContent:" #### CAP设计原则    - `一致性`（C）：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）    - `可用性`（A）：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）    - `分区容忍性`（P）：就是当由于网络故障之时，导致集群里的机器不能保证其互相保持正常通信之时，每台机器所具备各自为战能力，保证服务能否正常使用    CAP原则的精髓就是要么AP，要么CP，要么AC，但是不存在CAP。    如果在某个分布式系统中数据无副本， 那么系统必然满足强一致性条件， 因为只有独一数据，不会出现数据不一致的情况，此时C和P两要素具备    但是如果系统发生了网络分区状况或者宕机，必然导致某些数据不可以访问    此时可用性条件就不能被满足，即在此情况下获得了CP系统，但是CAP不可同时满足。必然导致某些数据不可以访问，此时可用性条件就不能被满足，即在此情况下获得了CP系统，但是CAP不可同时满足。    "},{title:"SRE",path:"/posts/md/develop/SRE.html",strippedContent:" SRE是指Site Reliability Engineer (网站可靠性工程师)。他是软件工程师和系统管理员的结合，一个SRE工程师基本上需要掌握很多  知识：`算法`，数据结构，`编程能力`，`网络编程`，`分布式系统`，`可扩展架构`，故障排除。    ，DevOps 可能缺乏 SRE 在一些专业领域的技能：     - 计算机体系结构能力；    - 高吞吐高并发优化能力；  - 可扩展系统设计能力；  - 复杂系统设计能力；  - 业务系统排查能力。     两者都需要软实力，但是 SRE 面临复杂度更高，挑战更大，要求也更高：    - 分析问题、解决问题能力  - 战胜困难决心  - 面对挑战热情  - 自驱学习"},{title:"架构师职位相关(二)",path:"/posts/md/develop/%E6%9E%B6%E6%9E%84%E5%B8%882.html",strippedContent:" ### 商汤科技招聘--术架构师/技术经理(35k-45k)    ##### 岗位职责：    - 根据公司业务规划，开展城市视觉智慧赋能产品架构相关设计与研发工作；  - 参与构建高性能，高可用，可扩展的分布式人工智能平台产品；  - 负责产品架构设计，影响产品路线图，构建智慧城市及AI+行业领域具有竞争力的智能化产品；  - 支撑AI产品、项目交付团队，完成产品对行业用户的赋能；  - 负责大中型项目的系统架构和概要设计，参与核心模块的代码编写，保证架构的落地交付；  - 深刻理解需求，对项目中的总体设计、模块设计进行确定、审查和把关；  - 决定项目中的关键问题和技术难题，丰富技术库；  - 参与售前阶段的产品白皮书、设计方案书、投标书、测试报告、实施方案等设计文档、POC等    ##### 任职要求：    - 8年以上java开发，5年以上架构设计经验，3年以上项目开发团队管理经验, 有SaaS或者PaaS架构设计以及相关JAVA开源技术方案者优先。有微服务架构、分布式架构、持续构建架构经验者优先。  - 有BPM, RuleEngine等的开发和架构设计经验者优先；有开放平台&API设计经验。  - 精通Java编程，熟练使用Spring framework(Spring Boot\\SpringMVC\\Spring Cloud\\Spring Data\\Spring Batch等), Javascript, JQuery；  - 精通高并发下的架构设计和高负载Web应用的关键技术，如容灾备份、负载均衡、集群、横向及纵向扩展。以及主流开源Web框架、消息系统，缓存系统，关系数据库系统，Linux操作系统。  - 熟悉PostgreSQL/MySQL/MongoDB/Cassandra数据库的管理、配置、使用等。  - 熟悉Tomcat/JBoss的管理、配置、使用等。   - 有elastic search/solr开发经验者优先。  -  有 Hadoop/HBase/Spark/Flink/Storm经验者优先  -  熟悉Docker与K8S者优先  - 工作积极努力，客观务实，具有良好的沟通、团队协作、工作计划和创新的能力。  - 软件工程，计算机科学，计算机工程，自动化，数学等相关专业本科及以上学历，技术优秀者学历可以放宽。    ------            ### 平安健康保险-- 0921GK-架构师(30k-50k)    ##### 工作职责   - 负责核心系统架构改造，优化，设计方案,开源项目的二次开发，达到项目自定义需求，编写系统相关的技术接口和规范文档       -  与运维合作，共同制定一些监控指标以及告警工具       - 负责业务核心代码的开发指导，新技术的引进及培训，参与公司的系统规划、功能模块规划、切分系统功能模块       - 负责理解和设计非功能性系统需求，包括软件的可维护性、性能、复用性、可靠性、有效性和可测试性等。       - 组织协调技术研究和攻关工作，组织及带领公司内部员工研究与项目相关的新技术               ##### 任职要求     -  `35岁`以下计算机相关专业，本科及以上学历     - 6年以上开发经验，4年以上平台架构设计经验，2年以上中大型系统设施实施经验 。至少研究过1个以上系统类开源产品的架构和源代码。     - 领导过5人以上的技术研发团队，良好的架构设计和技术指导能力，精通JAVA及相关技术，深入了解java开发工具及主流开发框架，具有扎实的技术功底，熟悉主流技术架构     - 精通Mysql/MongoDB数据库，熟悉Linux、REST架构、TCP/IP协议，精通面向对象的分析和设计技术，包括设计模式、UML建模等，有设计通用框架及模块的能力     - 熟悉RPC，异步、多线程、分布式、缓存、负载均衡、消息队列等技术的设计和应用     - 具有大型分布式系统的平台架构设计能力，有各协议层设计和实现经验者优先     - 诚恳、踏实，对技术和工作充满热情，有强烈的责任心、主动性和团队合作精神            ### 喜马拉雅--Java技术经理/架构师（26k-40k）    ##### 岗位职责    - 主导平台的后台架构设计与开发，搭建平台基础设施；    - 研究新的技术方案，调整服务端开发策略和技术架构，使之适应业务平台日益增长的需求。    ##### 任职要求    - 至少3年以上大规模分布式系统应用架构设计与研发经验，精通Java技术栈相关技术；    - 3年以上大型数据库如MySQL使用经验，具备分布式数据库如TDDL, TIDB等；    - 精通unix/linux操作系统；    - 精通分布式计算平台如storm， spark， flink等    - 精通缓存，如redis， pika， codis等；    - 精通分布式存储，如HDFS,Parquet,HBase；    - 有移动互联网架构如移动网关，应用性能管理，可视化埋点， ABTest，微服务化等经验者优先；    - 对开源技术有浓厚兴趣，有源代码阅读习惯；    - 具备良好的识别和设计通用框架及模块的能力。"},{title:"架构师职位相关(一)",path:"/posts/md/develop/%E6%9E%B6%E6%9E%84%E5%B8%88.html",strippedContent:" ### 拼多多--稳定性架构师(SRE)(30k-60k )    ##### 职位描述：  作为基础平台团队的一员，在拼多多，你每天将：    在社交电商领域排名第一的新兴独角兽公司中切身感受公司和个人同时高速成长的感觉；    在充满创造力和活力的年轻团队中，技术驱动业务，改变互联网电商行业；    为十亿级用户的电商平台提供稳定性保障支撑，规划技术方向，优化基础架构，打造强一致高可用的技术架构；    ##### 岗位职责：    - 对公司技术平台的稳定性负责，通过质量管理、过程管理、架构优化等手段不断提升系统稳定性；    - 建设全链路压测平台、容量评估和调度平台、稳定性模拟平台、可视化架构平台等来提升系统稳定性；  - 负责技术难点的攻坚，推动公司级的架构优化项目，指导并培训工程师，提升团队整体技术能力；    - 具有强烈的目标感、良好的服务意识和自我驱动力。      ##### 任职要求：    - 计算机相关专业本科及以上学历；  - 开发功底扎实，熟悉Java/Golang/C/C++单种或多种开发语言，对高并发高可用系统有深刻理解和实践经验；  - 熟悉大型互联网平台的架构，熟悉微服务框架、分布式组件、常见的存储组件并有丰富实践经验；  - 有容量调度管理、稳定性压测、架构优化、活动保障、混沌工程实践者优先；    -----            ### 万向区块链技术中心招聘 后端架构师 (30k-45k)    ##### 背景    - 5年以上开发经验  - 本科以上学历，计算机/软件相关专业优先    - 具备团队技术领导经验      ##### 要求    - 工作积极主动、耐心细心，能承受一定的工作压力，有很好的学习能力及强烈的责任心和团队合作的精神    - 态度良好，不排斥提携后进者    - 编程方向：精通Java或等面向对象语言，理解AOP（面向切面编程）等设计    - 主流开发框架：精通Tomcat、Nigix等常用应用容器部署与优化；精通Spring系列框架，熟悉Hibernate、MyBatis等技术；精通主流关系型数据库、NoSQL数据库应用，熟悉分布式缓存、数据持久化技术    - 参与过大型系统设计及开发    - 精通主流设计模式、泛型、数据结构及主要排序算法    - 对技术系统具有热诚，领导并主动积极参与及主持技术项目          ##### 职责    - 承担领导交付的任务    - 负责带领工程小组针对需求进行设计及开发，并在技术上有所要求，推动技术演进    - 研究及追踪技术演进，并带领小组进行技术尝试    - 参与管理各项技术框架及设计，推进开发项目完成    ------                ###  爱回收招聘 业务架构师(30k-50k)    ##### 岗位职责：    - 负责明确服务边界，参与技术评审；    - 建立业务线内中台与前台系统的协同机制    - 抽象和沉淀业务中台，避免重复建设；    - 建立业务线技术团队和集团技术中台的协同机制。          ##### 任职要求：    - 5年以上服务端开发经验，丰富的微服务架构能力；  - 熟悉领域驱动设计等主流建模方法，具备优秀的业务建模能力；    - 精通电商/O2O某一领域，并成功完成平台化建设；    - 丰富的项目管理经验，具备跨部门协调沟通能力；        "},{title:"知识名词",path:"/posts/md/develop/%E7%9F%A5%E8%AF%86%E5%90%8D%E8%AF%8D.html",strippedContent:" `DevOps`与`SRE `"},{title:"敏捷",path:"/posts/md/tool/%E6%95%8F%E6%8D%B7%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86.html",strippedContent:" 敏捷项目管理的项目流程制度上的管理可以看作是对一套完善的项目管理流程制度的裁剪，只不过这个裁剪的尺度比较大，  从而也对敏捷项目团队成员的适应性，自主性提出了较高的要求。  "},{title:"ElasticSearch",path:"/posts/md/tool/ElasticSearch.html",strippedContent:" #### 下载     https://www.elastic.co/products/elasticsearch     #### 运行  执行bin文件夹中的elasticsearch.bat ，查看  http://localhost:9200        #### 安装ik中文分词器  https://github.com/medcl/elasticsearch-analysis-ik/releases  - 选择和已经下载的elasticsearch版本兼容的ik。  - 解压后复制elasticsearch/plugins/ik(ik文件夹新创建)目录下  - 重新运行elasticsearch.bat        https://blog.csdn.net/u010391342/article/details/82117389"},{title:"总结",path:"/posts/md/develop/%E6%80%BB%E7%BB%93.html",strippedContent:" #### 学习时，需要产出文档，总结    #### 短期与长期目标之间的平衡    #### 急功近利   "},{title:"spring-boot全局排除jar",path:"/posts/md/part/spring/springboot/spring-boot%E5%85%A8%E5%B1%80%E6%8E%92%E9%99%A4jar.html",strippedContent:" 项目里使用了log4j2做日志处理，要排除掉Spring Boot 很多jar里边默认依赖的日志包spring-boot-starter-logging。一个一个写依赖排除也可以，  但是太繁琐了，经过尝试，只让它依赖个`spring-boot-starter-logging`的空壳，里边的东西全部排除掉即可。使用下边的方式就可以达到想要的效果。    ```xml   \x3c!--全局排除spring-boot-starter-logging内的所有依赖--\x3e          <dependency>              <groupId>org.springframework.boot</groupId>              <artifactId>spring-boot-starter-logging</artifactId>              <exclusions>                  <exclusion>                      <groupId>*</groupId>                      <artifactId>*</artifactId>                  </exclusion>              </exclusions>          </dependency>  ```      "},{title:"旅游计划",path:"/posts/md/plan/%E6%97%85%E6%B8%B8%E8%AE%A1%E5%88%92.html",strippedContent:" 苏州待玩的地方：    钮家巷      旺山  "},{title:"减肥计划",path:"/posts/md/plan/%E5%87%8F%E8%82%A5%E8%AE%A1%E5%88%92.html",strippedContent:" 买个苹果本，为期二个月（2019-10-21)：要求   - 减肥到63KG  - 戒小说  - 戒HB  - 每周一本书        跑步(20m)  深蹲(10m)  HITT全身(15M)  腹肌撕裂初(9m)        or   骑单车(30m)  HITT全身(15M)  HIIT核心燃烧(25m)  腹肌撕裂初(9m)    "},{title:"Redis高可用",path:"/posts/md/%E9%AB%98%E5%8F%AF%E7%94%A8/Redis%E9%AB%98%E5%8F%AF%E7%94%A8.html",strippedContent:" Redis`高可用`（High Availability）两种实现方式  - 主从复制数据。 - 哨兵模式     >网上给Redis加锁的机制都是利用Redis的setnx自身的方法去加锁,且防止死锁"},{title:"mq",path:"/posts/md/part/mq/mq.html",strippedContent:" 主题，发布订阅模式下的消息统一汇集地，不同生产者向topic发送消息，由MQ服务器分发到不同的订阅者，实现消息的广播  PPT当前页开始放映的快捷键是Shift+F5        需要为每个Consumer 指定一个Consumer Group，不同Group可读取相同消息；同一group内不同consumer 互斥，不会消费相同的消息  consumer 相关信息也在zk中维护"},{title:"心有不平",path:"/posts/md/other/%E5%BF%83%E6%9C%89%E4%B8%8D%E5%B9%B3.html",strippedContent:" ### 2019-08-20   物业打电话过来，收物业费，自己一顿说，周五过去，其实指的是周五去南京，而不是周五交物业费，瞎弄    ### 2019-08-06  洗的衣服被人放在很脏的凳子上，默默地拿起回屋子了，忍气吞声，应该大声怼回去。    -------------    ### 2019-07-22  小舅来上海玩，晚上带他们吃饭，住酒店，他们说随便，不能当真，还是要认真准备一下。      ### 2019-07-18  公司部门组织活动，自己出一部分钱，关键是我已经参加过一次，现在我又报名了，傻屌                "},{title:"片言支语",path:"/posts/md/other/%E7%89%87%E8%A8%80%E6%94%AF%E8%AF%AD.html",strippedContent:" #### 2019-06-21    - 勤加练习，必能得心应手！不期速成，日拱一卒 ！    - 知人者智，自知者明。胜人者有力，自胜者强。知足者富。强行者有志。不失其所者久。死而不亡者寿。  - 权力者:长久以后，以权力为自己能力，自以为是  ;过于简单,过于宏观    #### 2019-07-26   愿你走出半生，归来仍是少年   希望你经历过人生坎坷与挫折后，依然能够保持赤字之心，积极乐观，自信坦荡。           "},{title:"学习计划",path:"/posts/md/plan/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92.html",strippedContent:" | 集合           | 时间 | 完成情况 | | -------------- | ---- | -------- | | 集合           | 2W   |          | | JVM            | 2W |          | | 并发           | 4W |          | | 分布式         | 4W |          | | 缓存           | 2W |          | | 设计模式       | 2W |          | | 算法与数据结构 | 4W |          | | 微服务 |      |          |   "},{title:"19年3Q计划",path:"/posts/md/plan/%E8%AE%A1%E5%88%92.html",strippedContent:" | 阶段     | 时间点  | 目标 | 结果 |  | -------- | ------- | ---- | ---- |  | 第一阶段 | 6.2~7.1 |      |      |  | 第二阶段 | 7.2~8.2 |      |      |  | 第三阶段 | 8.3-9.1 |      |      |  |          |         |      |      |    "},{title:"作息计划",path:"/posts/md/plan/%E4%BD%9C%E6%81%AF%E8%AE%A1%E5%88%92.html",strippedContent:" #### 作息时间  ​\t22:30~6:00     9：30准备睡觉    ##### 晚睡的有两种人:  - 忙到不行，想要利用一天中最后一点时间； - 无所事事，但是没有勇气闭上双眼来结束这失败的一天，总想多做点什么，以此来减轻心中的愧疚感。   ------  晚上下班回来不要求自己做什么，只是放松，上班已经很累了，再学习或者运动，想想都会有抵触心理   >每在电脑前工作20分钟，就看看6米外的物体大概20秒   早睡让我学会了放下"},{title:"graphiQL使用",path:"/posts/md/part/web/graphql/graphiQL.html",strippedContent:' #### query    ```js  query fetchProductByCode($spuCode: ID!) {    shop {      productDetail(code: $spuCode) {        product {          id          title        }      }    }  }  ```            #### QUERY VARIABLES    ```json  {    "spuCode": "DV0125"  }  ```        > 使用的变量必须放在`query`参数中引入'},{title:"程序员",path:"/posts/md/develop/code.html",strippedContent:" #### 被淘汰    不思进取、放弃基本技能的程序员在34.9岁会被淘汰！,保持乐观的精神、积极学习才是我们每天都该做的"},{title:"运行docker web容器.",path:"/posts/md/docker/%E8%BF%90%E8%A1%8Cdocker%20web%E5%AE%B9%E5%99%A8.html",strippedContent:" #### 运行一个web应用 ```shell # 载入镜像 docker pull training/webapp    # 运行容器 docker run -d -P training/webapp python app.py # -d:让容器在后台运行。 # -P:将容器内部使用的网络端口映射到我们使用的主机上。  # 查看容器内部运行的进程 docker top wizardly_chandrasekhar  # 查看 Docker 的底层信息。它会返回一个 JSON 文件记录着 Docker 容器的配置和状态信息 docker inspect wizardly_chandrasekhar   # 重启WEB应用容器，已经停止的容器，可以使用命令 docker start 来启动。 docker start wizardly_chandrasekhar  # 正在运行的容器，我们可以使用 docker restart 命令来重启 docker restart  wizardly_chandrasekhar  # 移除WEB应用容器(删除容器时，容器必须是停止状态) docker rm wizardly_chandrasekhar ```  > docker镜像的名字中不能包含大写字母,改成小写 > 如果你不指定一个镜像的版本标签，例如你只使用 ubuntu，docker 将默认使用 ubuntu:latest 镜像。  ```shell # docker redis 启动  --privileged=true加权限 docker run --privileged=true   -p 6379:6379 -v /root/data:/data \\   -d docker.io/redis:5.0.5 redis-server --appendonly yes  # 连接、查看容器,使用redis镜像执行redis-cli命令连接到刚启动的容器 docker exec -it 0bf909dfb2d2 redis-cli ``` "},{title:"docker nginx",path:"/posts/md/docker/docker%20nginx.html",strippedContent:" ### nginx  ```shell  docker run --privileged=true  -d -p 8080:80 --name runoob-nginx-test-web \\    -v ~/nginx/www:/usr/share/nginx/html -v ~/nginx/conf/nginx.conf:/etc/nginx/nginx.conf \\    -v ~/nginx/logs:/var/log/nginx nginx:1.15.12  ```    "},{title:"全球统计一生后悔的五件事",path:"/posts/md/other/%E5%85%A8%E7%90%83%E7%BB%9F%E8%AE%A1%E4%B8%80%E7%94%9F%E5%90%8E%E6%82%94%E7%9A%84%E4%BA%94%E4%BB%B6%E4%BA%8B.html",strippedContent:" 全球统计一生后悔的五件事：    1、92%的人后悔年轻时努力不够一事无成    2、73%的人后悔没有好好珍惜身边的亲人    3、62%的人后悔跟错了人    4、63%的人后悔年轻时选错了职业    5、45%的人后悔没有善待自己身体  "},{title:"备忘",path:"/posts/md/plan.html",strippedContent:" 英国剧作家萧伯纳曾说过：自我控制是最强者的本能。   有很多人会将这句话奉为人生励志金句：“体重都无法控制，还怎么控制人生！”     很多人做事就靠三分钟的热度吊着，三天打鱼，两天晒网，激情过后，留下的就是唯有迷茫。  一个人要想取得成功，坚持是最基本的素养。    其实这里涉及到一个人自律的问题，体重和人生并没有实际的关联性，但必须肯定地是，一个能控制自己体重的人，确实是可怕又可敬的，他们身上都有着这样的特质。  如果你只有计划，只有目标是远远不够的，不行动那一切都是扯淡。我个人是比较讨厌和反感经常抱怨的人，抱怨不能改变什么，只会让你更加地消极。  可怜之人必有可恨之处，这句话用在一些整天喊着有才无门的人身上很适用。自己不去努力改变，别人能帮的了你一时，却不可能帮助你一辈子。  试着给自己制定一个计划，然后坚持去做一个月、两个月，到时候看看你能收获多少？      在数据结构、网络、框架、数据库和分布式"},{title:"spring cloud",path:"/posts/md/problem/spring%20cloud.html",strippedContent:" 使用新Greenwich.SR1部署 eureka server 时    ##### Caused by: java.lang.ClassNotFoundException: com.sun.jersey.api.core.DefaultResourceConfig    缺少jar    ```xml  <dependency>      <groupId>com.sun.jersey</groupId>      <artifactId>jersey-bundle</artifactId>      <version>1.19</version>  </dependency>  ```    "},{title:"Shell输出重定向到空设备文件",path:"/posts/md/linux/Linux%E4%B8%8BShell%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91%E5%88%B0%E7%A9%BA%E8%AE%BE%E5%A4%87%E6%96%87%E4%BB%B6.html",strippedContent:" Linux下使用shell命令时经常使用类似这样的Shell输出重定向:    1>/dev/null 2>&1    在Shell命令的结尾，我们可以通过>符号来重定向输出。    1. 标准输入stdin文件描述符为0，标准输出stdout文件描述符为1，标准错误stderr文件描述符为2    2. /dev/null 空设备文件，相当于垃圾桶    3. 重定向符号：>    逐一解释上面的Shell重定向命令：    （1）  >符号代表输出重定向    （2）  >前面的数字:    0代表标准输入  1代表stdout标准输出，默认值为1，所以”1>/dev/null”可以简写为”>/dev/null”  2代表stderr标准错误输出    （3）2>&1代表把stderr标准错误输出 重定向 到stdout标准输出    所以，1>/dev/null 2>&1的解释就是    将stdout标准输出重定向到空设备文件/dev/null ，同时将stderr标准错误输出的重定向跟stdout标准输出重定向一致，也输出到空设备文件/dev/null。"},{title:"Springboot",path:"/posts/md/problem/spring-boot.html",strippedContent:" ### Springboot Filter中注入bean 无效为null    问题原因：    Web应用的启动顺序是：Lisenter->Fliter->Servlet,  应用程序上下文， 初始化 Fliter的时候，还没有初始化Servlert，所有没有进入DispacterServlet的初始化，故在Fliter中使用注解注入bean为空；    解决办法：    添加初始化bean配置，手动创建对象new  "},{title:"mybatis",path:"/posts/md/problem/mybatis.html",strippedContent:" ### mybatis报错 Specified class is an interface    #### 1.错误原因    Caused by: org.springframework.beans.factory.BeanCreationException:     Error creating bean with name 'admUserMapper' defined in file   [E:\\idea_soft\\workspace\\xxxx-mircoservices\\i\\classes\\main\\com\\imassbank\\admin\\mapper\\AdmUserMapper-\\classes\\main\\com\\admin\\mapper\\AdmUserMapper.class]:   Instantiation of bean failed; nested exception is org.springframework.beans.BeanInstantiationException:     Failed to instantiate [com.xxxxxx.mapper.AdmUserMapper]: Specified class is an interface         #### 2.原因以及解决方案    1）原因:AdmUserMapper有重复的，  例如  AdmUserMapper   在 a工程中有  但是 在b工程中  并且 叫相同的名字   导致  spring 在加载时 调用mapper解析器 导致出错    2）解决方法  重命名"},{title:"go优缺点",path:"/posts/md/langu/go/go.html",strippedContent:" 使用 Go 语言的`缺点`  - 缺少框架  - 错误处理  - 软件包管理"},{title:"部署方式",path:"/posts/md/part/cicd/%E9%83%A8%E7%BD%B2%E6%96%B9%E5%BC%8F.html",strippedContent:" ### 金丝雀部署  先部署单台服务器，金丝雀测试（国内常称灰度测试）通过，则全部部署    简单的金丝雀测试一般通过手工测试验证，复杂的金丝雀测试需要比较完善的监控基础设施配合，通过监控指标反馈，观察金丝雀的健康状况，作为后续发布或回退的依据      >`优势` ： 用户体验影响小，体验较平滑      > `不足`：发布自动化程度不够，发布期间可引发服务中断    "},{title:"docker相关",path:"/posts/md/problem/docker.html",strippedContent:" ### docker构建脚本报：  Syntax error : end of file unexpected (expecting “then”)      >用vim   操作 startup.sh  :set fileformat=unix修改ubuntu 和linux服务器、 dos等非图形界面冲突  :wq保存"},{title:"vim使用",path:"/posts/md/tool/vim.html",strippedContent:" ### vim中文乱码        ```bash  ##配置文件，开头添加以下配置  set fileencodings=utf-8,ucs-bom,gb18030,gbk,gb2312,cp936  set termencoding=utf-8  set encoding=utf-8  ```    "},{title:"rocketmq",path:"/posts/md/%E9%AB%98%E5%8F%AF%E7%94%A8/rocketmq.html",strippedContent:" ```shell  nohup sh bin/mqnamesrv &  tail -f ~/logs/rocketmqlogs/namesrv.log      nohup sh mqbroker -n localhost:9876 -c conf/broker.conf &    nohup sh bin/mqbroker -n localhost:9876 -c conf/broker.conf  autoCreateTopicEnable=true  &       tail -f ~/logs/rocketmqlogs/broker.log          export NAMESRV_ADDR=localhost:9876       #关闭rocketmq  sh bin/mqshutdown broker  sh bin/mqshutdown namesrv  ```    "},{title:"如何查找SHELL的进程号并杀死",path:"/posts/md/linux/%E5%A6%82%E4%BD%95%E6%9F%A5%E6%89%BESHELL%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%8F%B7%E5%B9%B6%E6%9D%80%E6%AD%BB.html",strippedContent:" ### shell查找进程并杀死 ```shell #!/bin/sh  tomcat_id=`ps -ef | grep tomcat | grep -v \"grep\" | awk '{print $2}'` echo $tomcat_id  for id in $tomcat_id do     kill -9 $id       echo \"killed $id\"   done ``` >注意：tomcat表示要查找的程序进程名，如：tomcat、8081端口、redis等等。   ### linux查找进程并杀死   ```shell #####查找tomcat进程 ps -ef | grep tomcat | grep -v grep | awk '{print $2}' #####查找tomcat进程并杀死 ps -ef | grep tomcat | grep -v grep | awk '{print $2}' | xargs kill -9   ```"},{title:"Nacos配置的加载规则详解",path:"/posts/md/part/microServices/Nacos%E9%85%8D%E7%BD%AE%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%A7%84%E5%88%99%E8%AF%A6%E8%A7%A3.html",strippedContent:" ### 配置管理  - Data ID中的`alibaba-nacos-config-client`：对应客户端的配置`spring.cloud.nacos.config.prefix`，默认值为`${spring.application.name}`，即：服务名 - Data ID中的`properties`：对应客户端的配置`spring.cloud.nacos.config.file-extension`，默认值为`properties` - Group的值`DEFAULT_GROUP`：对应客户端的配置`spring.cloud.nacos.config.group`，默认值为`DEFAULT_GROUP`  在采用默认值的应用要加载的配置规则就是：`Data ID=${spring.application.name}.properties`，`Group=DEFAULT_GROUP`  ```yaml server:   port: 9000  spring:   application:     name: alibaba-nacos-discovery-client    # server discovery   cloud:     nacos:       discovery:         server-addr: 127.0.0.1:8848  ```"},{title:"情商50则",path:"/posts/md/other/%E6%83%85%E5%95%8650%E5%88%99.html",strippedContent:" 1，话别说太满，人别熟太快。   3，不要把别人想得太坏，也不要把别人想得太好，都是凡人。   2，别人自嘲可以，但你千万别附和   4，可以嘲笑你的朋友，但不能嘲笑他喜欢的东西。    34，自嘲是最高境界，而不是嘲笑别人。   ---   6，刚开始和对方不熟悉的时候，聊到晚上十点多对方发来消息就别回复了，第二天早晨再回复，这样又可以聊一天。   7，把“随便”改成“听你的”。   23，把“听明白了吗”换成“我说明白了吗”。   5，把每一句“我不会”都改成“我可以学”   把“谢谢”改成“谢谢你” 并微笑看着对方的眼睛     ---   8，别人骂你你要听，别人夸你你别信。    9，请道歉而不是取笑别人开不起玩笑，你以为谁没有底线只不过还没到底而已。    10，聊天时别人发微笑，你不知道怎么回的话，就回，你笑得真好看。  11，能用表情包解决的就不要说脏话！   12，恰到好处的装逼，适可而止的套路。    13，如果一个人不理你，有可能是对方的问题；如果大家都不理你，那你就要考虑自身问题了。   ---  14，人前不应该说的话，背后也别说。   27，不要在公众场合揭别人的短处，让别人难堪。   35，请不要随意出卖一个朋友的隐私来取悦另一个不熟的朋友。   46，不要人后捅刀子嘴别贱。   ---  15，在最愤怒时忍住最伤人对方的那句话。   17，不要把负能量带给身边的人。   18，不要吝啬你的赞美和表达爱意的语言。   40，越是亲近的人越要用心对待，一句随意的话会伤害她。   42，千万不要为了恋爱而淡了身边所有人。   21，真的不必把太多人请进生命里，太多热情总是不被珍惜。   ---  16，如果没有十足的把握和必要，就不要轻易说假话。   19，女孩子永远抗拒不了陪她通宵聊天的人。   20，刻薄嘴欠和幽默是两回事；口无遮拦和坦率是两回事；没有教养和随性是两回事；轻重不分和耿直是两回事。   ---    22，如果遇到了傻Ⅹ，不要与他争论，而且要同意他的一切观点，把他培养成大傻Ⅹ。   24，不能侮辱别人的idol，谨记！   47，践踏别人的梦想等同于谋杀。   ---   25，在拒绝这件事上，越简单越好，明明是别人需求自己帮忙，解释半天变成自己亏欠了别人的感觉，帮得上，想帮就帮，帮不上，就拒绝。人际交往，简单明了有时最恰当，懂得拒绝，才可以洒脱不纠结。   33，学会拒绝，没人会感激你的善良，他们只会得寸进尺。   ---   26，逢人只说三分话，未可全抛一片心。   29，看透不说透，还是好朋友。   39，最印象的一句话，“交友不必言尽，言尽则无友”    ---   28，社交没那么容易，每个人都有他的手机。 30，当你往上爬的时候对别人好一点，因为你走下坡路的时候会遇到他们。 ---  31，颜值要高，脾气要好，原则要有。   36，有分寸的信任，有理由的怀疑。   37，把身材练好，把妆化好。   41，修得豆腐嘴，藏得刀子心。   43，清醒时做事，糊涂时读书，大怒时睡觉，独处时思考。   ---  32，该叫阿姨的叫姐，该叫姐的叫美女该叫美女的叫妹子。   38，不会讲话时别瞎说沉默微笑更好。   44，永远不要听信别人口中的他。   45，女生之间的嫉妒心太可怕，不要公开说这个女生比那个好看。   48，常与同好争高下，不共傻瓜论短长。——出自《欢乐颂》  "},{title:"这就是人生",path:"/posts/md/other/%E8%BF%99%E5%B0%B1%E6%98%AF%E4%BA%BA%E7%94%9F.html",strippedContent:" 孤独是人生的常态，一定要拥有真正喜欢的兴趣爱好，这样才能支持你渡过无数个漫漫长夜和无数个孤独的时候，读书则是成本最低的兴趣爱好。很多人看起来什么都感兴趣，啥都能参与一定点但都不深入，这种人是最孤独的，因为他根本不知道自己想要什么，喜欢什么。  绝大部分焦虑不过是脑子勤奋（想的太多）和身体懒惰之间的矛盾，自视甚高是人之常情，但一般要等到人到中年才能明白。20岁：我一定行——40岁：我本可以——60岁：我真的不行哎，是大部分人的人生轨迹。  一个人行不行可能早就注定了，比如家庭，比如言行举止，比如不经意间的流露……比如知乎的提问，大部分人都不懂得先问是不是再问为什么，大部分人都来懒的出奇，对自己不负责任，问的很随便，不说任何前提，不说任何自己情况，比如太多人问什么专业好、XX专业有没有前景、550分能读什么学校……只有这几个字，惜墨如金守口如瓶的，这些人将来基本上都会庸庸碌碌一辈子。因为思考意识具有决定性作用，跟年龄关系不大，如果你跟顶级中学的高中生聊过天 ，会发现她们比很多大学生有思想有见识，问问题的时候会把个人和家庭情况、问题背景、愿景交待的很清楚。  对于大部分人来说，体制内尤其是公务员是最好是工作，因为大部分人到了中年才会明白自己不过是庸人，是站在路边给别人喝彩，坐在台下给别人鼓掌的人，年轻时所谓的理想情怀豪言壮语只是对自己不了解，或者人云亦云。  大部分人一辈子也不会遇到轰轰烈烈荡气回肠的爱情，不过的找一个能接受的，不喜欢也不讨厌，甚至不那么讨厌的人将就着，婚姻，不过是人生的例行公事。  大部分失败的婚姻不是败给大是大非，而是日常再小不过的琐事，零刀子割肉没感觉，时间长了才会发现情感已经跌破发行价了。跟门当户对、经济条件、颜值相比，一个有趣的人开朗的人善良的人积极阳光的人，重要的多。大多数的婚姻失败不是大是大非的原则性问题，而是无数细枝末节的煎熬和落差，天长日久的日常摩擦，好的性格和心态，可以避免和减少大多数以上不快。  婚姻的真谛不只是爱，更多是忍受，求同存异，利弊权衡。  绝大多数人找的媳妇儿都不如大学里的恋人，能在大学找个媳妇儿就尽量，毕业后你会发现你根本找不到这么好的了，甚至可以让你越来越绝望。不被父母祝福的婚姻大概率是不会幸福的，尤其是远嫁、两人落差太大，都是一种孤军深入式的冒险。  没有遭遇大的意外，比如战争、大的天灾、绝症、残疾，有一份能养家糊口的工作就是一种幸福甚至幸运，当然你不会觉察到，直到失去。大部分人一辈子也没有一个真正的爱好，没有被谁真爱过，真爱过谁，没有痛痛快快哭过笑过，都是复制黏贴型人生。  绝大多数人都有阴暗面，即便一辈子不为人所知。人性是最不靠谱的东西，法律和契约最实实在在的。  大多数人一辈子也没有真正的朋友，所谓的朋友不过是同学、同事、同行、熟人甚至亲戚邻居身份的外延，别看平时亲密热烈，你好我好，一遇到事情，朋友二字就褪色了。朋友也不是人生的标配，友情也不是一成不变的，因为每个人都是在变化之中，当再次见面时，大家说着言不由衷的话，去没有什么交集时，就让这份友情活在对往事的回忆中去吧。  除了父母，真的很少有人想你好，大部分人盼你倒大霉。  大部分人都会受父母的影响，这种影响是骨子里的，越想摆脱越摆脱不了，会草蛇灰线伏延几十年，尤其是人到中年，有一天会突然发现自己变成了讨厌的模样，被父母附体。  大部分人，一辈子和文艺也没有交集，看电影看个热闹，听音乐听个响，看书图个刺激，虽然朋友圈都是纳兰容若、尼采。文艺青年大都会在潦倒、衰败、激愤、穷酸中渡过一生。  出轨、堕落是一种戒不了毒，不要指望用感动、谅解、宽恕去改变，当然也有回头是岸立地成佛的，但概率低到你不敢冒险。  知乎大部分故事都是假的，教人月入XX年入XX大都是收智商税的，推荐的东西大部分用处不大，思维、决策、分析等高赞文章大都是自问自答，也是心理学管理学书社会学籍上都有的，基本上属于收藏不看系列。  残忍归残忍，可日子也得过不是，罗曼罗兰那句话不是都会背了嘛。其实也谈不上残忍，这就是真实的人生，只不过大部分人把生活想的太美好而已。"},{title:"linux压缩与解压",path:"/posts/md/linux/linux%E5%8E%8B%E7%BC%A9%E4%B8%8E%E8%A7%A3%E5%8E%8B.html",strippedContent:" ```shell # 解压window中压缩的文件，不会文件名包含中文乱码 unzip -O CP936 xxx.zip ```   1. #### tar -c: 建立压缩档案 -x：解压 -t：查看内容 -r：向压缩归档文件末尾追加文件 -u：更新原压缩包中的文件  这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。下面的参数是根据需要在压缩或解压档案时可选的。  -z：有gzip属性的 -j：有bz2属性的 -Z：有compress属性的 -v：显示所有过程 -O：将文件解开到标准输出  下面的参数-f是必须的  -f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。  #### 示例 ```shell ##### 压缩 tar –cvf jpg.tar *.jpg      // 将目录里所有jpg文件打包成tar.jpg tar –czf jpg.tar.gz *.jpg   // 将目录里所有jpg文件打包成jpg.tar后，生成gzip压缩过的包，命名为jpg.tar.gz tar –cjf jpg.tar.bz2 *.jpg  // 将目录里所有jpg文件打包成jpg.tar后，生成bzip2压缩过的包，命名为jpg.tar.bz2 tar –cZf jpg.tar.Z *.jpg    // 将目录里所有jpg文件打包成jpg.tar后，生成umcompress压缩过的包，命名为jpg.tar.Z rar a jpg.rar *.jpg         // rar格式的压缩，需要先下载rar for Linux zip jpg.zip *.jpg           // zip格式的压缩，需要先下载zip for linux  #####  解压 tar –xvf file.tar           //解压 tar包 tar -xzvf file.tar.gz       //解压tar.gz tar -xjvf file.tar.bz2      //解压 tar.bz2 tar –xZvf file.tar.Z -C /opt/dev      //解压tar.Z unrar e file.rar            //解压rar unzip file.zip -d /opt/dev             //解压zip ```"},{title:"生活中有哪些残忍的真相",path:"/posts/md/other/%E7%94%9F%E6%B4%BB%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E6%AE%8B%E5%BF%8D%E7%9A%84%E7%9C%9F%E7%9B%B8.html",strippedContent:" 1、如果你八岁，十八岁，二十八岁都没有漂亮起来，那这辈子大概率就没法好看了（男生同理）  解：变有钱，变有内涵，变豁达，提升好看概率，实在不行，提升自己看得开的能力。  2、大部分人终其一生都不能拥有及格的原生家庭，及格的校园生活，及格的职场发展，以及及格的婚姻和后代  解：降低及格线，严以律己宽以待人，庸人不自扰。  3、迷茫是人生80%的状态，剩下的百分之二十，都是一些俗不可耐的目标，比如考大学，比如找工作，比如谈对象，比如买房买车生孩子，恰恰是这些俗不可耐的目标才能暂时将你从迷茫的状态里拯救出来。  解：做好当下一件事，接受迷茫的状态但不沉沦，或者试试把共产主义作为新的理想？  4、算计，衡量，比较，得失利弊分析将贯穿大部分人的一生，洒脱，率性而为是很多人向往的状态，却很难做到。  解：算计过程，衡量结果，但是不算计人心，不衡量感情。洒脱有时候真的意味着卸下很多责任，但凡人在世，岂能没有责任？  5、攒钱，省吃俭用其实才是大部分人的生存之道，不然你以为拼多多是怎么火起来的，我听过投资需谨慎，理财有风险的，可从没听说过攒钱有风险，储蓄需谨慎的。  解：没人知道十年后房价暴涨，与其遗憾，不如适当积蓄，给自己一个底气。  6、有时候感情双方都是彼此的Plan B，却还要在婚礼上宣誓此生唯一。  解：Plan B也是Plan，因为A计划失败，不得不启动B计划，还记得第一个发明可乐的人吗，他的A计划是止咳药来着，但是B计划更盈利不是吗？  7、孩子比较爱父母的时候一般是自己无助的时候，父母比较爱孩子的时候一般是自己比较得意的时候。所以事业生活不顺的家长大多会打骂孩子，而混的风生水起的孩子容易忽略父母。（是的，就是这么扎心，父母子女之间的爱也有爱得可以为对方死，非常爱，比较爱，一般爱，不爱，讨厌，恨，恨不得对方去死等不同等级）。  解：这是唯一一个无解的真相，只能参考第一题最后一句，提升自己看得开的能力。  8、养个不如意的孩子会严重影响夫妻感情，家庭关系，声称孩子是宝贝天使的父母，心里都在给自己孩子悄悄打分，这个分数一直能打到儿女退休那天，退休金高低也会成为最后一项得分。  解：养孩子之前，对自己进行充分评审和考核，确定孩子无论什么样，都不后悔做一遭父母，再带孩子来到这个世界上，如果只是把孩子当做自己人生的一个加分项，那说到底还是不配为人父母。  9、鄙视链真实存在于各行各业，各种阶层，而且处于鄙视链高层的人经常表态的一句话是：我并不觉得XXX的人会有这样的缺点，也不会看不起他们，只是阅历见识不同，三观不同，没法聊得来。潜台词就是：我鄙视你，我不要跟你玩！处于底层的人则经常说这样的话：他们不过是XXXX，其实不也是XXX，谁稀罕他们！潜台词就是：你们那边好像很好玩，为啥不喊我一起玩?！  解：努力成为鄙视链的上端，不然永远逃不脱鄙视链。  10、大多数人理智上知道嫉贤妒能是错误的，但感情上已经红了眼，会在各种打擦边球的地方做小动作，让如日中天的人稍微落下西山，然后还会自我安慰：这事情并不能怨我，我能做什么啊，根本不会影响到的。  解：得意时谨言慎行，失意时不落井下石，已经是很厉害的人了。  11、生活中也许会发生，但只要电视剧里作为主题来演的，那一定是小概率事件：比如穷人家女孩嫁给富二代；比如家徒四壁的穷孩子考上了清北；比如后爸后妈对孩子视如己出，辛苦养育，感人泪下；比如抱错孩子刚好其中一家是很有钱而由此引发的十八年后的二十集剧情；比如你爱的人刚好也爱你。。。。  因为不常发生，所以有演绎的价值，可惜蠢人总喜欢拿小概率事件当自家剧本，穷还不思进取，坐等孩子考清华，家庭矛盾都四分五裂了，还不快刀斩乱麻，就在那坐等突发事件发生，人设逆转然后阖家团圆（是的，点名批评最近热门剧“都挺好”的走向，这种剧情会麻痹多少病态的家庭，让他们误以为一切家庭乱象都会有这样的美好结尾）。  解：看清楚什么是小概率事件，才能在大多数不如意事情发生的时候泰然处之，而又能在小概率事情发生时珍惜美好的那一刻。  12、残忍的真相就是人人都知道真相，但还要合起来粉饰太平。  解：生活的本质是钟摆运动，两端是繁花似锦，中间是漫长的平平无奇，粉饰太平也许是在摆动至下一个美好节点期间能做的最大的努力。  罗曼罗兰那句耳熟能详的话作为结尾：There is only one heroism in the world: to see the world as it is and to love it.  我写的这个答案的确很扎心，但是这并不是本意，扎心只是一瞬的感触，剩下的时间里依然过好每一天，才是大部分人的选择，我想看过我答案的人，并不会因为这些答案扎心就放弃继续生活了吧。  我写的解其实也都是大多数人知道的道理，只是知道和做到，不是一回事，像我自己，扎心的真相都是我亲身经历，但是我也在努力践行我自己的英雄主义，与大家共勉。"},{title:"如果成长就是向世界妥协，你愿意为了适应社会而磨平棱角吗？",path:"/posts/md/other/%E5%A6%82%E6%9E%9C%E6%88%90%E9%95%BF%E5%B0%B1%E6%98%AF%E5%90%91%E4%B8%96%E7%95%8C%E5%A6%A5%E5%8D%8F%EF%BC%8C%E4%BD%A0%E6%84%BF%E6%84%8F%E4%B8%BA%E4%BA%86%E9%80%82%E5%BA%94%E7%A4%BE%E4%BC%9A%E8%80%8C%E7%A3%A8%E5%B9%B3%E6%A3%B1%E8%A7%92%E5%90%97.html",strippedContent:" 我也曾经以为我在妥协，后来发现我只是自说自话地感动自己罢了，就像你长大了明白你是两性生殖产生的，而不是像小时候妈妈告诉你，你是路边上捡来的。  这叫妥协吗……？  简单的来讲，套用逼乎模版，我可以说：（太长不看版）  1.先问是不是，再问为什么。成长是认识世界的过程，一草一木皆是世界，臭水沟是世界，乌托邦也是世界，小孩子可能只见识到世界的5%，而20岁的你可能见识到了10%，等四十不惑的时候可能到了25%，当我们悲伤逆流成河地说自己跟世界“妥协”了，你有没有想过，  这个宾语，所谓“世界”，你真的知道是什么吗？到底跟谁妥协的呢？美国国家妥协局？中国人民妥协部？你是在遍历了世界所有元素之后，然后说，这就是世界，我真的看透了，所以我不得不为了生存而修改自己的初心？  2.以大部分人的认知阅历水平，是没资格谈论自己的所谓“初心”被抹平的。你都不知道自己到底想要啥，还谈个锤子的初心？就像全中国你能够抓出来100万个创业者，连街边卖地瓜的都算，他也有梦想，他也会振振有词告诉你怎么从卖地瓜到卖坦克走向人生巅峰。  但这不意味着他真的拥有或者配拥有一个普遍意义上他能够驾驭的比较合理的梦想，梦想是个宏大叙事，而平头百姓烫头百姓很难说自己有资格探讨宏大叙事。就像你不能说自己看了本《时间简史》就说自己算是科学家了，你这充其量是个科晓家，少看点郭德纲吧。  3.私以为，很多人有这种疑问，还是因为过于“顾影自怜”+“对世界认识不到位”。就像第一点探讨的，世界就是世界，你也是世界的一部分，它不是割裂的，不是随着18岁生日的蜡烛吹灭，突然骤然忽然莫名其妙地就巨变了质变了。  你的所谓初心，类比一下，就好比windows系统，你中学是windows98，高中是windowsXP，大学是win8，等到成家立业可能变成了win10，难道你告诉我，“当年我像win98一样简陋的初心，当初我想当科学家，后来我成绩不好上了专科，我的梦想破灭了，我为了生存不得不跟世界妥协！”这不是很可笑吗？之所以有人能当科学家，是因为他们有资格当，而不仅仅是因为他们想当，你想当，那你就拿出证据。  win10之所以比前几版好使，不是它跟谁妥协了，是它更成熟了，更完善了，更适应时代了，你可以说98和XP也有很多独到之处，但是事实上，他们就是落伍了，他们也并不因为你的情怀，而变得可以亘古不变价值永恒，如果你觉得自己的初心是不可更改不可妥协的，我觉得90%的可能是你太自恋。记住，情怀，绝大多数时候，都是自恋，难道不是吗？  你的初恋，你念念不忘，但是关我屁事呢？我会对她/他高看一眼吗？不会。  你的梦想，你不能平息，但是我凭什么就得理解你呢？你爱干嘛干嘛与我无关啊。  先看看题主的问题：  在成人世界里，一直保持一颗初心和童真，怕是一件非常难的事儿吧。 > 随着逐渐年长，人们总是在不停地向现实妥协，在守护心灵中的理想世界和接受世俗融入社会之间，大部分人都被迫选择了后者，世界给这种举动起了一个很好听的名儿：成长。 > 于是成长在成人世界里的含义，往往都是残酷的。 > 有的时候你会羡慕那些一直天真乐观的大孩子，因为他们就像年轻时候的自己；也会心疼那些保持初心却饱受现实摧残的「边缘人士」，也想要劝他们跟现实和解。 > 大多数时候，不是我们选择「自我阉割」，而是被生活「阉割」；很多经历促使你变得理性克制近乎冷淡、迟钝抗压近乎麻木，平滑老道近乎世故，因为这才是现在这个社会的生存之道。 > 如果可以选择的话，你会选择接受现实从而活的容易一些，还是宁愿跌跌撞撞也要永远年轻热泪盈眶?  我是很有资格探讨这种问题的，初心，初恋，热血，激情，本愿，这些高大上的词汇，大家都有，我更有。 曾经中学的我，也是非常文艺的，我敢说比很多自诩文艺青年的人都更有资格，毕竟，那些熟读唐诗三百首的人，大概还是不如我这种写了诗歌300首的有资格说自己文艺吧，你行你也写呗，对吧。短篇也写了十几篇，长篇大概开了两个坑，我的理想就是去当个写手，甚至作家。我知道这条路很难，但是我想，韩寒，郭敬明，蒋方舟，这些人不都或多或少跟我有点像，他们能够成功，我为什么不能？  当然，这都不重要，我只是想证明，我确实有自己的初心，我也有点资格说自己有这个初心。  后来呢？我当然没有那么冲动，我没有辍学，我还是坚持学习，同时笔耕不辍，想着等我高考完，立马开始投稿，各种投，我写的也杂，我写诗歌，也写短篇小说，写长篇校园小说（类似于韩寒那种），也写科幻小说，我觉得自己还是挺有天赋的吧，我也觉得自己是独特的。  显然，我自然是四处碰壁，投稿别说拒稿，人家根本不回复你，你都以为自己是不是没有发过去。  另一方面，高中的时候，我一直是我们班里的前五名，万年掉不出去，我只要不自暴自弃，怎么都是前五，第一倒是少有，第二第三考过好几次，我觉得自己还是学习蛮好的吧，我觉得自己既文艺，又兼顾学业，多厉害啊。所以我觉得，我的前途是充满未知却金光灿烂的，我可以成为学霸型写手，以后那真是风光无限，美女如云……  然而？  投稿石沉大海，而且随着我在网上看各种文章，逛文学类贴吧，找所谓文字工作室（网上的小团体，收稿子卖钱那种），我才了解到，原来文字圈是这样，别说扬名立万了，现在出版社本身就不景气，你想出书也容易，几万块就可以出，然而意义何在？你说你想出名？不好意思，本来现在看书的就少，推广成本你没个上百万你根本推不出去，而且，文字圈毕竟是讲究圈子的，就像娱乐圈一样，不是你够努力够砸钱就能够混成当成炸子鸡的，你需要贵人伯乐，你需要切入点好机会……  这些，在最初形成我的初心的时候，我是都不知道的，所以赖谁呢？赖世界吗？  高考，更有意思了，我这个全班名列前茅的人只高了一本线一分，根本上不了什么正经的一本，我之前也知道我们班不是好班，但是谁知道到底放在高考的尺度下算是什么水平呢，对吧？  最后我们班一共才有五六个人过了一本线，最好的一个才去了青岛大学而已，这就是赤裸裸的世界，我的初心自然被打破了。  还是那个问题，这赖谁呢？赖世界没有给我一个我以为的预期吗？  难道这些不是世界本来的面目吗？投稿很难，难道不是一直都那样吗，出版业不景气，你自己不知道你赖谁呢？高考难，难道不是全中国人都该知道的吗，你以为自己学习很好，那又如何呢？大家都想考北大清华所以大家都该上吗？  因为你不知道，所以你就非常唯心主义的觉得，不对，这跟我想的不一样，所以世界错了，你们错了， 你们要按我说的改！  您是上帝吗？  再来看题主的话：  > 随着逐渐年长，人们总是在不停地向现实妥协，在守护心灵中的理想世界和接受世俗融入社会之间，大部分人都被迫选择了后者，世界给这种举动起了一个很好听的名儿：成长。  现实并没有变化，变化的是你而已，世俗也一直就是那样，只是你一直蹲在新手村看不见而已，大部分人当然选择后者，不然呢？就你特殊可以不去适应世界是吗？ 进化论还不明白吗？尼安格特人怎么灭绝的？是因为他们不够强大，被我们的祖先给竞争灭绝了，你不想融入世俗，您就接受灭绝就好了，你有今天的这个肉体，全仰赖你的老祖宗积极入世。  > 有的时候你会羡慕那些一直天真乐观的大孩子，因为他们就像年轻时候的自己；也会心疼那些保持初心却饱受现实摧残的「边缘人士」，也想要劝他们跟现实和解。  一直的乐观天真，到底是一种**不自知的愚昧**，还是一种大无畏的乐观主义？  > 大多数时候，不是我们选择「自我阉割」，而是被生活「阉割」  文艺青年总喜欢说这种玄了吧唧的废话，我当年就是这样——自我阉割也好，被别人阉割也好，本质上是为了融入世界，你完全可以不融入，死掉就好咯，就这么简单。何况，所谓“自我阉割”，到底是自己越来越有逼数，越来越不那么狂妄愚昧，还是真的你一个天选之子不得不屈服于浮尘俗世？  丑小鸭不屈服于群体，那是因为人家基因里就是天鹅，你要是鸭子怎么办？  换句话说，你是选择主动认错，还是被别人揍一顿之后被教做人？  > 很多经历促使你变得理性克制近乎冷淡、迟钝抗压近乎麻木，平滑老道近乎世故，因为这才是现在这个社会的生存之道。  很多人以为变得理性就是变得迟钝，变得博学就是变得麻木，不好意思，我们家是县城的，我们家是做生意的，我从小到大就见识了太多底层家庭，底层人民，我还算是知道普罗大众的精神面貌和认知水平的，从农村的工人大爷，到城里的穷苦泼妇，从学校的天真中产，到大学的官富二代。  难道天真就意味着不迟钝？难道愚昧就意味着活力四射？  就像当年那个充满激情，满脑子未来憧憬的自己，我不知道投稿有多难，我不知道自己作品水平没那么好，我不知道自己高考就那么回事，我甚至也不知道自己到底多丑多帅……  所以当年那个我，就是所谓“不冷淡，不麻木，不圆滑不世故”的好青年了？  你当然可以说当年的自己是充满热血的，但是这不意味着中二少年就是值得敬佩的，这充其量，是人生的一个阶段，就像小处男夜夜幻想着美女的胴体，然后过了几年有了孩子反而性冷淡了，你难道还能分出个优劣来？你就应该一辈子都跟个小处男一样，像个泰迪一样看着谁都想日？这就是青春永驻了？这就是有意义的人生？  > 如果可以选择的话，你会选择接受现实从而活的容易一些，还是宁愿跌跌撞撞也要永远年轻热泪盈眶?  如果说我们有的选择的话，大概这句话还有点意义， 就像当初的我，我可以选择留在国内，按部就班来毕业找工作，考国家电网或者公务员，也可以选择出国留学充满未知和机遇，走一条比较艰险的路。  但是要说“跌跌撞撞也要永远年轻热泪盈眶”这就太符合我一开始说的，“自我感动”“不自知不自觉”“顾影自怜”，不要觉得我无情，毕竟，本人自己就非常中二过，我也有资格说自己追梦吧，你们有本事也写几百首诗然后投稿啊挣扎啊，别光口嗨啊对吧？我好歹真的去做了。  所以恰恰因为这样，我才认识到自己当初多么狂妄，多么自恋，多么无知。  这个世界不是给你准备的，你不是主角，你只是75亿人里面的一个罢了。  成长本质上就是越来越认识这个世界的面貌，越来越熟悉里面的规则，你会觉得这些东西残酷，那是因为，当你在父母的庇护下的时候，你不需要考虑这些——但不意味着这些不存在，因为当时——是你的父母在考虑这些，不是你。当你成为父母的时候，你的孩子也会一样，心安理得地造梦，觉得世界是他自己的，所有人都该围着他转，有这种心态这很正常，但是你不能一辈子都这样，这也不是对的。  所以总而言之，我们幻想出一个“棱角”来取悦自己的内心，让自己以为曾经，自己也是个勇士也是英雄，只是俗世逼自己一个大人物妥协，这个心态很常见，但是它是不靠谱的，你也根本就是普普通通的人罢了，你根本没有什么牛逼闪闪的“棱角”，被什么巨兽恶魔所打磨，你只是越来越有逼数了，越来越认识到自己在这个社会里的位置，世界到底是什么样子，你修正自己的航线，是为了不至于撞冰山撞死，而不是什么伟大的“壮士断腕”，  说难听点，你当年的梦想，一文不值。就像我当年的梦想，一文不值，但是这并不妨碍我继续前进，不然，也没有我今天知乎上的这个答案对吧？"},{title:"如何相处",path:"/posts/md/other/%E5%A6%82%E4%BD%95%E7%9B%B8%E5%A4%84.html",strippedContent:" 像个傻逼一样，明知道不应该做的事，还非要去做  能有点出息不，对自己狠一点  想想那些放弃自己的人，让她们后悔  可能不抽烟不喝酒的男人对智障的容忍度没那么高  容易让某些相信这种话的群体产生疏离感。  哈哈哈，就是智商优越感  看人的眼神就像看`白痴`。。。。。。  继续不喝酒吸烟，但是眼神柔和了，弱势群体需要爱护嘛"},{title:"uml",path:"/posts/md/tool/uml.html",strippedContent:" ### 口决 * 虚箭实现实泛化 * 虚线依赖实关联 * 空菱聚合实组合  #### 泛化 用一条带空心箭头的直接表示，通常在程序里面泛化表现为继承于非抽象类。  #### 实现 用一条带实心箭头的虚线表示。通常程序里面实现关系表现为继承抽象类,或接口。  #### 聚合 用一条带空心菱形箭头的直线表示。与组合关系不同的是，整体和部分不是强依赖的，即使整体不存在了，部分仍然存在。  #### 组合 用一条带实心菱形箭头直线表示，如果整体不存在了，部分也不复存在  #### 依赖 用一套带箭头的虚线表示，描述一个对象在运行期间会用到另一个对象的关系。通常在程序里面通过构造函数、形参等体现。  #### 关联 用一条直线表示，当然如果需要标明方向可以添加箭头，通常不会随着状态的变化而变化。通常在程序里面以类变量的方式表现。 "},{title:"spring cloud gateway 入门",path:"/posts/md/part/microServices/spring%20cloud/spring%20cloud%20gateway%20%E5%85%A5%E9%97%A8.html",strippedContent:' ```xml <dependencies>     <dependency>         <groupId>org.springframework.cloud</groupId>         <artifactId>spring-cloud-starter-gateway</artifactId>     </dependency>     \x3c!-- 集成eureka --\x3e     \x3c!--<dependency>         <groupId>org.springframework.cloud</groupId>         <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>     </dependency>--\x3e </dependencies> ``` spring-cloud-gateway有两种配置方式，一种是在application.yml中配置，一种是使用@Bean对象注入。（注意：二者选其一）  #### application.yml方式 ```yml spring:   cloud:     gateway:       routes:       - id: WEB         uri: http://127.0.0.1:8661         predicates:         - Path=/web/{segment}         filters:         - SetPath=/{segment}         - StripPrefix=1 ```  #### @Bean对象注入配置方式  ```java @Bean public RouteLocator routeLocator(RouteLocatorBuilder builder) {     return builder.routes()             .route("WEB", r -> r.path("/web/{segment}")                     .filters(f -> f.setPath("/{segment}"))                     .uri("http://127.0.0.1:8661"))             .build(); } ```  简要说明：  * id：路由的id，参数配置不要重复，如不配置，gateway会使用生成一个uuid代替。 * uri：路由的目标地址。注意：uri地址后面不要加 " / " * Path：配置路由的路径。比如：/web/{segment}则表示当访问http://127.0.0.1:8562/web/**时候路由的指定的uri上面 * SetPath：在发起请求时，在路由请求路径后面加上web/后面的内容。如果不配置，将无法路由地址后缀/web/index，只能路由/web * StripPrefix 去掉转发根据路径web   '},{title:"微服务健康检查",path:"/posts/md/part/microServices/spring%20cloud/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5.html",strippedContent:" #### 健康检查  ```properties #开启健康检查（需要spring-boot-starter-actuator依赖） eureka.client.healthcheck.enabled=true ```  ```yml #应用信息 /actuator/info info:   app:     name: @project.name@     description: @project.description@     version: @project.version@     encoding: @project.build.sourceEncoding@     java:       version: @java.version@ ```     ```xml         <dependency>             <groupId>org.springframework.boot</groupId>             <artifactId>spring-boot-starter-actuator</artifactId>         </dependency> ```"},{title:"洁面-洗面奶",path:"/posts/md/other/%E7%94%B7%E5%A3%AB%E6%8A%A4%E8%82%A4.html",strippedContent:" **洁面-洗面奶**    **水温：一定选择和皮肤温度相近的水温**，不要觉得夏天太热就用凉水，冬天太冷就用较烫的水，这都会刺激到皮肤；**最后可以用稍凉一些的水收尾，达到收缩毛孔的效果。**    **手法：**在脸上转圈打炮泡，注意T区等容易出油的部位可以多照顾一些，没什么好说的。    **时间：不低于30秒，不超过三分钟；**不要觉得洗的时间越长越好。    **注意**：洗完及时擦干脸上的水分，刚洗完脸，毛孔张开状态下，水分蒸发更容易带走皮肤的水分。"},{title:"真正的精致",path:"/posts/md/other/%E7%9C%9F%E6%AD%A3%E7%9A%84%E7%B2%BE%E8%87%B4.html",strippedContent:" * 真正的精致，其实藏在别人看不见的地方。 * 真正的精致，是即使穷困潦倒，也要让生活过得有滋有味。 * 真正的精致，是给生活做减法，让心灵回归理性。  《一代宗师》里有这样一句话：“人活在世上，有的人活成了面子，有的人活成了里子。”   别让自己为了面子而活，被假精致所绑架。   内心真正丰富充盈的人，才可以拥抱真正的精致。"},{title:"事务的四种隔离级别",path:"/posts/md/db/%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB.html",strippedContent:" ### 事务的四种隔离级别  |                  | 脏读 | 不可重复读 | 幻读 | | ---------------- | ---- | ---------- | ---- | | Read uncommitted | X    | X          | X    | | Read committed   | √    | X          | X    | | Repeatable read  | √    | √          | X    | | Serializable     | √    | √          | √    |  1. **ISOLATION_READ_UNCOMMITTED**：读未提交，这是事务最低的隔离级别，它充许令外一个事务可以看到这个事务未提交的数据。          这种隔离级别会产生脏读，不可重复读和幻像读。、  2. **ISOLATION_READ_COMMITTED**：读已提交，保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据  3. **ISOLATION_REPEATABLE_READ**：可重复读，这种事务隔离级别可以防止脏读，不可重复读。但是可能出现幻像读。          它除了保证一个事务不能读取另一个事务未提交的数据外，还保证了避免下面的情况产生(不可重复读)。  4.  **ISOLATION_SERIALIZABLE**：串行化，这是花费最高代价但是最可靠的事务隔离级别。事务被处理为**顺序执行**。          除了防止脏读，不可重复读外，还避免了幻像读。     "},{title:"git使用",path:"/posts/md/tool/git%E4%BD%BF%E7%94%A8.html",strippedContent:" ####  解决git pull 和 git push 每次都需要输入密码的问题  > `git config --global credential.helper store` > 之后再次执行git push 或者git pull这时候还需要输入用户名和密码,下次就不需要了  ---   #### 回滚远程提交   git reset --hard HEAD^  git push --force"},{title:"问题日志",path:"/posts/md/problem/web.html",strippedContent:"### Invalid character found in method name. HTTP method names must be tokens|the HTTP protoco  `因为请求协议不对，需要统一成https或http请求`     ---  "},{title:"docker设计",path:"/posts/md/docker/docker%E8%AE%BE%E8%AE%A1.html",strippedContent:" ##### Docker通过引人分层文件系统构建和高效的镜像机制，降低了迁移难度"},{title:"dist文件使用",path:"/posts/md/part/web/js/dist%E6%96%87%E4%BB%B6%E4%BD%BF%E7%94%A8.html",strippedContent:" ###  生成dist目录 npm run build    ### 安装express-generator生成器    执行  $ npm install express-generator -g  进行安装      ###  创建一个express项目   执行  $ express expressDemo （expressDemo是项目名）      ### 进入expressDemo目录，安装项目依赖    npm install                   ### 把dist目录下的所有文件复制到express项目的public文件夹下   然后运行 $ npm start 启动expressDemo   打开浏览器，输入 <http://localhost:3000>, 就可以看到效果了"},{title:"go介绍",path:"/posts/md/langu/go/go%E4%BB%8B%E7%BB%8D.html",strippedContent:' **Go**（又称**Golang**）是Google开发的一种`静态强类型`、`编译型`、`并发型`，并具有`垃圾回收`功能的编程语言。  ### 描述 Go的语法接近C语言，但对于变量的声明有所不同。Go支持垃圾回收功能。Go的并行模型是以东尼·霍尔的`通信顺序进程`（CSP）为基础，采取类似模型的其他语言包括Occam和Limbo，但它也具有Pi运算的特征，比如通道传输。在1.8版本中开放`插件`（Plugin）的支持，这意味着现在能从Go中`动态加载部分函数`。  Go内嵌了`关联数组`（也称为哈希表（Hashes）或字典（Dictionaries）），就像字符串类型一样  ### 撰写风格 在Go中有几项规定，而且这些是强制的，当不匹配以下规定时编译将会产生错误。  - 每行程序结束后不需要撰写分号（;）。 - 大括号（{）不能够换行放置。 - if判断式和for循环不需要以小括号包覆起来。  > Go亦有内置gofmt工具，能够自动整理代码多余的空白、变量名称对齐、并将对齐空格转换成Tab    #### 指针示例  指针变量 `*` 和地址值 `&` 的区别：指针变量保存的是一个地址值，会分配独立的内存来存储一个整型数字。当变量前面有 `*` 标识时，才等同于 `&` 的用法，否则会直接输出一个整型数字。  ```go func main() {    var a int = 4    var ptr *int    ptr = &a    println("a的值为", a);    // 4    println("*ptr为", *ptr);  // 4    println("ptr为", ptr);    // 0xx000xx } ```'},{title:"markdown语法",path:"/posts/md/tool/markdown%E8%AF%AD%E6%B3%95.html",strippedContent:" ###  列表嵌套  列表嵌套只需在子列表中的选项添加四个空格即可：  ``` 1. 第一项：     - 第一项嵌套的第一个元素     - 第一项嵌套的第二个元素 2. 第二项：     - 第二项嵌套的第一个元素     - 第二项嵌套的第一个元素 ```  #### 换行 一行字后面添加`两个空格`才换行"},{title:"分布式事务",path:"/posts/md/%E7%9F%A5%E8%AF%86%E7%82%B9/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1.html",strippedContent:" ### 分布式事务  1. 主流的关系型数据库产品都是实现了XA接口，事务管理器和资源管理器之间使用XA协议，JTA(Java Transaction API)。 2. `TCC`   try  comfirm   cancel 。 3. `本地消息表`    采用定时轮询扫描的方式，去检查消息表的数据。 4. `消息队列`    采用时效性高的MQ，由对方订阅消息并监听，有消息时自动触发事件。 5. `mq事务消息`    RocketMQ    第一阶段发送Prepared消息时，会拿到消息的地址，      第二阶段执行本地事物，      第三阶段通过第一阶段拿到的地址去访问消息，并修改状态。      如果确认消息发送失败了，RocketMQ会定期扫描消息集群中的事物消息，      这时候发现了Prepared消息，它会向消息发送者确认，      Bob的钱到底是减了还是没减呢，RocketMQ会根据发送端设置的策略来决定是回滚还是继续发送确认消息。      这样就保证了消息发送与本地事务同时成功或同时失败。 6. `补偿机制`    只有当我们回调页面中输出了success字样或者标识业务处理成功相应状态码时，支付宝才会停止回调请求。    否则，支付宝会每间隔一段时间后，再向客户方发起回调请求，直到输出成功标识为止。"},{title:"支付流程",path:"/posts/md/part/interview/%E6%94%AF%E4%BB%98%E6%B5%81%E7%A8%8B.html",strippedContent:" 1. 获取支付交易流水号 2. 生成签名，拼成交易链接 3. 支付成功，同步异步返回结果，异步每隔一段时间发送 4. 修改完给支付宝返回success  "},{title:"Sidecar模式：下一代微服务架构的关键",path:"/posts/md/%E7%9F%A5%E8%AF%86%E7%82%B9/Sidecar.html",strippedContent:" # Sidecar模式：下一代微服务架构的关键  ## 什么是Sidecar模式？  Sidecar模式是一种将应用功能从应用本身剥离出来作为单独进程的方式。该模式允许我们向应用无侵入添加多种功能，避免了为满足第三方组件需求而向应用添加额外的配置代码。  就像边车加装在摩托车上一样，在软件架构中，sidecar附加到主应用，或者叫父应用上，以扩展/增强功能特性，同时Sidecar与主应用是松耦合的。  举个例子，假设现在有6个相互通信的微服务，每个微服务都需要具有可观察性、监控、日志记录、配置、断路器等功能，而所有这些功能都是在微服务中使用一些第三方库实现的。  这样一组服务的实际情况可能会非常复杂，增加了应用的整体复杂性，尤其是当每个微服务用不同的语言编写、使用不同的基于.net、Java、Python等语言的第三方库  "},{title:"多线程",path:"/posts/md/%E7%9F%A5%E8%AF%86%E7%82%B9/%E5%A4%9A%E7%BA%BF%E7%A8%8B.html",strippedContent:" 多线程只有一个目的：更好的利用cpu的资源  - 并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。 - 并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。  - 线程安全：经常用来描绘一段代码。指在并发的情况之下，该代码经过多线程使用，线程的调度顺序不影响任何结果。 - 同步：Java中的同步指的是通过人为的控制和调度，保证共享资源的多线程访问成为线程安全，来保证结果的准确。如简单加入@synchronized关键字。  **阻塞(Blocked)**：  1. 调用join()和sleep()方法，sleep()时间结束或被打断，join()中断,IO完成都会回到Runnable状态，等待JVM的调度。 2. 调用wait()，使该线程处于等待池(wait blocked pool),直到notify()/notifyAll()，线程被唤醒被放到锁定池(lock blocked pool )，释放同步锁使线程回到可运行状态（Runnable） 3. 对Running状态的线程加同步锁(Synchronized)使其进入(lock blocked pool ),同步锁被释放进入可运行状态(Runnable)。    Thread类中的yield方法可以让一个running状态的线程转入runnable。  - yield()应该做的是让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会，可能无效，又选择了让步的线程。 - join()在一个线程中调用other.join(),将等待other执行完后才继续本线程。 - interrupted方法其本质只是设置该线程的中断标志，真正实现线程的中断原理是：开发人员根据中断标志的具体值，来决定如何退出线程。 - stop方法会中断一个正在运行的线程   synchronized, wait, notify 是任何对象都具有的同步工具 monitor 在synchronized 范围内，监视器发挥作用 wait/notify必须存在于synchronized块，这三个关键字针对的是同一个监视器，意味着wait之后，其他线程可以进入同步块执行。  `volatile 多线程的内存模型`： main memory（主存）、working memory（线程栈）   在处理数据时，线程会把值从主存load到本地栈，完成操作后再save回去(volatile关键词的作用：每次针对该变量的操作都激发一次load and save)。    ### 多线程包:java.util.concurrent  `ThreadLocal类`，每个使用该变量的线程提供独立的变量副本，常用于用户登录控制，如记录session信息 每个Thread都持有一个TreadLocalMap类型的变量  `原子类`（AtomicInteger、AtomicBoolean……）等同于synchronized，AtomicInteger.compareAndSet(int expect,int update)可实现乐观锁     #### Lock类 ReentrantLock   ReentrantReadWriteLock.ReadLock   ReentrantReadWriteLock.WriteLock   lock 阻塞式, trylock 无阻塞式, lockInterruptily 可打断式， 还有trylock的带超时时间版本   r.lock()或r.lockInterruptibly()   r.unlock()   ReentrantReadWriteLock，写写，写读互斥；读读不互斥。可以实现并发读的高效线程安全代码  #### 容器类 BlockingQueue 这个queue是单向队列，特别适用于先进先出策略的一些应用场景，BlockingQueue在队列的基础上添加了多线程协作的功能，提供了阻塞接口put和take，带超时功能的阻塞接口offer和poll。put会在队列满的时候阻塞，直到有空间时被唤醒；take在队列空的时候阻塞，直到有东西拿的时候才被唤醒。用于生产者-消费者模型尤其好用，堪称神器 常见的阻塞队列有： `ArrayListBlockingQueue` `LinkedListBlockingQueue` `DelayQueue` `SynchronousQueue` `ConcurrentHashMap`    高效的线程安全哈希map。请对比hashTable , concurrentHashMap, HashMap  **HashMap**  put(key, value)存储对象到HashMap中，使用get(key)从HashMap中获取对象 put()方法传递键和值时，我们先对键调用hashCode()方法，返回的hashCode用于找到bucket位置来储存Entry对象 HashMap是在bucket中储存键对象和值对象    #### 线程池管理类ThreadPoolExecutor corePoolSize:池内线程初始值与最小值，就算是空闲状态，也会保持该数量线程。   maximumPoolSize:线程最大值，线程的增长始终不会超过该值。   keepAliveTime：当池内线程数高于corePoolSize时，经过多少时间多余的空闲线程才会被回收。回收前处于wait状态   unit：时间单位，可以使用TimeUnit的实例，如TimeUnit.MILLISECONDS。   workQueue:待入任务（Runnable）的等待场所，该参数主要影响调度策略，如公平与否，是否产生饿(starving)  。   threadFactory:线程工厂类，有默认实现，如果有自定义的需要则需要自己实现ThreadFactory接口并作为参数传入。      有一个内存区域是jvm虚拟机栈，每一个线程运行时都有一个线程栈，线程栈保存了线程运行时候变量值信息。当线程访问某一个对象时候值的时候，首先通过对象的引用找到对应在堆内存的变量的值，然后把堆内存变量的具体值load到线程本地内存中，建立一个变量副本，之后线程就不再和对象在堆内存变量值有任何关系，而是直接修改副本变量的值，在修改完之后的某一个时刻（线程退出之前），自动把线程变量副本的值回写到对象在堆中变量。这样在堆中的对象的值就产生变化了。 "},{title:"jvm编译类加载和执行",path:"/posts/md/langu/jdk/jvm%E7%BC%96%E8%AF%91%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C.html",strippedContent:" JVM是Java Virtual Machine（Java虚拟机），Java虚拟机是实现跨平台这一特点的关键。  Java代码编译和执行的整个过程包含了以下三个重要的机制：  1. `Java源码编译机制` 2. `类加载机制` 3. `类执行机制`  #### Java源码编译机制：  1. 分析和输入到符号表 2. 注解处理 3. 语义分析和生成class文件  class文件包括结构信息。包括class文件格式版本号及各部分的数量与大小的信息元数据。对应于Java源码中声明与常量的信息。包含类/继承的超类/实现的接口的声明信息、域与方法声明信息和常量池 方法信息。对应Java源码中语句和表达式对应的信息。包含字节码、异常处理器表、求值栈与局部变量区大小、求值栈的类型记录、调试符号信息  ------ #### 类加载机制 JVM的类加载是通过ClassLoader及其子类来完成的 1.Bootstrap ClassLoader 负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class 2.Extension ClassLoader 负责加载java平台中扩展功能的一些jar包，包括$JAVA_HOME中jre/lib/*.jar或-Djava.ext.dirs指定目录下的jar包 3.App ClassLoader 负责记载classpath中指定的jar包及目录中class 4.Custom ClassLoader 属于应用程序根据自身需要自定义的ClassLoader，如tomcat、jboss都会根据j2ee规范自行实现ClassLoader  加载过程中会先检查类是否被已加载，检查顺序是自底向上，从Custom ClassLoader到BootStrap ClassLoader逐层检查，只要某个classloader已加载就视为已加载此类，保证此类只所有ClassLoader加载一次。而加载的顺序是自顶向下，也就是由上层来逐层尝试加载此类。  #### 类执行机制 JVM是基于栈的体系结构来执行class字节码的。线程创建后，都会产生程序计数器（PC）和栈（Stack），程序计数器存放下一条要执行的指令在方法内的偏移量，栈中存放一个个栈帧，每个栈帧对应着每个方法的每次调用，而栈帧又是有局部变量区和操作数栈两部分组成，局部变量区用于存放方法中的局部变量和参数，操作数栈中用于存放方法执行过程中产生的中间结果  类加载生命周期 `加载`、`连接`、`初始化`、`使用`、`卸载` hotspot虚拟机是当真正用到一个类的时候才对它进行加载。  #####   加载：  找到需要加载的类并把类的信息加载到jvm的方法区中，然后在堆区中实例化一个java.lang.Class对象 1. 通过一个类的全限定名（包名与类名）来获取定义此类的二进制字节流（Class文件）。 2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。 3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。  ##### 连接  - 验证：验证被加载后的类是否有正确的结构，类数据是否会符合虚拟机的要求，确保不会危害虚拟机安全。 - 准备：为类的静态变量（static filed）在方法区分配内存，并赋默认初值（0值或null值）。静态常量（static final filed）会在准备阶段赋程序设定的初值，如static final int a = 666;  静态常量a就会在准备阶段被直接赋值为666，对于静态变量，这个操作是在初始化阶段进行的。 - 解析：将类的二进制数据中的符号引用换为直接引用。在解析阶段，jvm会将所有的类或接口名、字段名、方法名转换为具体的内存地址。  ##### 初始化 初始化阶段才真正执行Java代码。 类的初始化的主要工作是为静态变量赋程序设定的初值。 没有static修饰的赋值语句和执行语句在实例化对象的时候才会运行。  ------  #### 执行过程 #####  执行过程简介 当编译和连接一个C++程序时，所获得的可执行二进制文件只能在指定的硬件平台和操作系统上运行，因为这个二进制文件包含了对目标处理器的机器语言。而Java编译器把Java源文件的指令翻译成字节码，这种字节码就是Java虚拟机的“机器语言”。 与普通程序不同的是，Java程序（class文件）并不是本地的可执行程序。当运行Java程序时，首先运行JVM（Java虚拟机），然后再把Java class加载到JVM里头运行，负责加载Java class的这部分就叫做Class Loader。 #####  JVM中的ClassLoader JVM本身包含了一个ClassLoader称为`BootstrapClassLoader`，和JVM一样，BootstrapClassLoader是用本地代码实现的，它负责加载核心JavaClass（即所有java.*开头的类）。另外JVM还会提供两个ClassLoader，它们都是用Java语言编写的，由BootstrapClassLoader加载；其中`ExtensionClassLoader`负责加载扩展的Javaclass（例如所有javax.*开头的类和存放在JRE的ext目录下的类）`ApplicationClassLoader`负责加载应用程序自身的类。 当运行一个程序的时候，JVM启动，运行bootstrapclassloader，该ClassLoader加载java核心API（ExtClassLoader和AppClassLoader也在此时被加载），然后调用ExtClassLoader加载扩展API，最后AppClassLoader加载CLASSPATH目录下定义的Class，这就是一个程序最基本的加载流程。 #####  执行ClassLoader例子 什么时候JVM会使用ClassLoader加载一个类呢？当你使用java去执行一个类，JVM使用ApplicationClassLoader加载这个类；然后如果类A引用了类B，不管是直接引用还是用Class.forName()引用，JVM就会找到加载类A的ClassLoader，并用这个ClassLoader来加载类B。JVM按照运行时的有效执行语句，来决定是否需要装载新类，从而装载尽可能少的类，这一点和编译类是不相同的。  "},{title:"jvm内存加载和gc",path:"/posts/md/langu/jdk/jvm%E5%86%85%E5%AD%98%E5%8A%A0%E8%BD%BD%E5%92%8Cgc.html",strippedContent:" jvm比较重要的内存区域   `方法区`：在java的虚拟机中有一块专门用来存放已经加载的类信息、常量、静态变量以及方法代码的内存区域，叫做方法区。   `常量池`：常量池是方法区的一部分，主要用来存放常量和类中的符号引用等信息。   `堆区`：用于存放类的对象实例。   `栈区`：也叫java虚拟机栈，是由一个一个的栈帧组成的后进先出的栈式结构，栈桢中存放方法运行时产生的局部变量、方法出口等信息。当调用一个方法时，虚拟机栈中就会创建一个栈帧存放这些数据，当方法调用完成时，栈帧消失，如果方法中调用了其他方法，则继续在栈顶创建新的栈桢。 除了以上四个内存区域之外，jvm中的运行时内存区域还包括`本地方法栈`和`程序计数器`  1）堆  所有通过new创建的对象的内存都在堆中分配，堆的大小可以通过-Xmx和-Xms来控制。   堆被划分为`新生代`和`旧生代`，新生代又被进一步划分为`Eden`和`Survivor`区，最后Survivor由From Space和To Space组成  `新生代`。新建的对象都是用新生代分配内存，Eden空间不足的时候，会把存活的对象转移到Survivor中， 新生代大小可以由-Xmn来控制，也可以用-XX:SurvivorRatio来控制Eden和Survivor的比例  `旧生代`。在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。  `持久代`。已经取消，JDK8 HotSpot JVM现在使用了本地内存来存储类元数据，被称为Metaspace。   2）栈 每个线程执行每个方法的时候都会在栈中申请一个栈帧，每个栈帧包括局部变量区和操作数栈，用于存放此次方法调用过程中的临时变量、参数和中间结果。  3）本地方法栈 用于支持native方法的执行，存储了每个native方法调用的状态  4）方法区 存放了要加载的类信息、静态变量、final类型的常量、属性和方法信息。  基本回收算法 1. 引用计数（Reference Counting）  比较古老的回收算法。原理是此对象有一个引用，即增加一个计数，删除一个引用则减少一个计数。垃圾回收时，只用收集计数为0的对象。此算法最致命的是无法处理循环引用的问题。  2. 标记-清除（Mark-Sweep）  此算法执行分两阶段。第一阶段从引用根节点开始标记所有被引用的对象，第二阶段遍历整个堆，把未标记的对象清除。此算法需要暂停整个应用，同时，会产生内存碎片。  3. 复制（Copying）  此算法把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。次算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不过出现“碎片”问题。当然，此算法的缺点也是很明显的，就是需要两倍内存空间。  4. 标记-整理（Mark-Compact）  此算法结合了 “标记-清除”和“复制”两个算法的优点。也是分两阶段，第一阶段从根节点开始标记所有被引用对象，第二阶段遍历整个堆，把清除未标记对象并且把存活对象 “压缩”到堆的其中一块，按顺序排放。此算法避免了“标记-清除”的碎片问题，同时也避免了“复制”算法的空间问题。  5. 增量收集（Incremental Collecting）  实施垃圾回收算法，即：在应用进行的同时进行垃圾回收。不知道什么原因JDK5.0中的收集器没有使用这种算法的。  6. 分代（Generational Collecting）   垃圾收集器 串行GC（Serial GC）、并行回收GC（Parallel Scavenge）和并发回收GC（ParNew）  GC有两种类型：`Scavenge GC`和`Full GC`。  JVM分别对新生代和旧生代采用不同的垃圾回收机制      JVM内存调优 使用JDK提供的内存查看工具，比如JConsole和Java VisualVM。   首先需要注意的是在对JVM内存调优的时候不能只看操作系统级别Java进程所占用的内存，这个数值不能准确的反应堆内存的真实占用情况，因为GC过后这个值是不会变化的，因此内存调优的时候要更多地使用JDK提供的内存查看工具，比如JConsole和Java VisualVM。      对JVM内存的系统级的调优主要的目的是减少GC的频率和Full GC的次数，过多的GC和Full GC是会占用很多的系统资源（主要是CPU），影响系统的吞吐量。特别要关注Full GC，因为它会对整个堆进行整理，导致Full GC一般由于以下几种情况：  旧生代空间不足     调优时尽量让对象在新生代GC时被回收、让对象在新生代多存活一段时间和不要创建过大的对象及数组避免直接在旧生代创建对象   Pemanet Generation空间不足     增大Perm Gen空间，避免太多静态对象       统计得到的GC后晋升到旧生代的平均大小大于旧生代剩余空间     控制好新生代和旧生代的比例   System.gc()被显示调用     垃圾回收不要手动触发，尽量依靠JVM自身的机制       调优手段主要是通过控制堆内存的各个部分的比例和GC策略来实现，下面来看看各部分比例不良设置会导致什么后果  1）新生代设置过小      一是新生代GC次数非常频繁，增大系统消耗；二是导致大对象直接进入旧生代，占据了旧生代剩余空间，诱发Full GC  2）新生代设置过大      一是新生代设置过大会导致旧生代过小（堆总量一定），从而诱发Full GC；二是新生代GC耗时大幅度增加          一般说来新生代占整个堆1/3比较合适  3）Survivor设置过小      导致对象从eden直接到达旧生代，降低了在新生代的存活时间  4）Survivor设置过大      导致eden过小，增加了GC频率          另外，通过-XX:MaxTenuringThreshold=n来控制新生代存活时间，尽量让对象在新生代被回收          由内存管理和垃圾回收可知新生代和旧生代都有多种GC策略和组合搭配，选择这些策略对于我们这些开发人员是个难题，JVM提供两种较为简单的GC策略的设置方式  1）吞吐量优先      JVM以吞吐量为指标，自行选择相应的GC策略及控制新生代与旧生代的大小比例，来达到吞吐量指标。这个值可由-XX:GCTimeRatio=n来设置  2）暂停时间优先      JVM以暂停时间为指标，自行选择相应的GC策略及控制新生代与旧生代的大小比例，尽量保证每次GC造成的应用停止时间都在指定的数值范围内完成。这个值可由-XX:MaxGCPauseRatio=n来设置        最后汇总一下JVM常见配置  堆设置    -Xms:初始堆大小     -Xmx:最大堆大小     -XX:NewSize=n:设置年轻代大小  -XX:NewRatio=n:设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4  -XX:SurvivorRatio=n:年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor=3：2，一个Survivor区占整个年轻代的1/5  -XX:MaxPermSize=n:设置持久代大小  收集器设置  -XX:+UseSerialGC:设置串行收集器  -XX:+UseParallelGC:设置并行收集器  -XX:+UseParalledlOldGC:设置并行年老代收集器  -XX:+UseConcMarkSweepGC:设置并发收集器  垃圾回收统计信息  -XX:+PrintGC    -XX:+PrintGCDetails    -XX:+PrintGCTimeStamps    -Xloggc:filename  并行收集器设置  -XX:ParallelGCThreads=n:设置并行收集器收集时使用的CPU数。并行收集线程数。  -XX:MaxGCPauseMillis=n:设置并行收集最大暂停时间  -XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+n)  并发收集器设置  -XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况。  -XX:ParallelGCThreads=n:设置并发收集器年轻代收集方式为并行收集时，使用的CPU数。并行收集线程数。     "},{title:"拦截器与Filter的区别",path:"/posts/md/%E7%9F%A5%E8%AF%86%E7%82%B9/Filter%E4%B8%8EHandle.html",strippedContent:" ### 拦截器与Filter的区别  * 相似之处：都是AOP编程思想的体现，都能实现权限检查与日志记录等  * 不同之处：  1. 使用范围不同     ​\tFilter是Servlet规范规定的，只能用于Web程序中     ​\t拦截器既可用于Web程序，与可用于Application,Swing程序中  2. 规范不同     ​\tFilter是在Servlet规范定义的，是Servlet容器支持的.     ​\t而拦截器是在Spring容器内，是Spring框架支持的  3. 使用资源不同     ​\t拦截器是Spring的一个组件，可以使用spring相关服务，如对象，事务，数据源     ​\t而Filter不能  4. 深度不同     ​\tFilter在Servlet前后启作用，拦截器则可以在方法前后，异常抛出前后"},{title:"面试知识点确认",path:"/posts/md/part/interview/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E7%A1%AE%E8%AE%A4.html",strippedContent:" socket多线程                     ok netty底层nio，aio                ok  高并发                           ok 分布式事务                       ok 事务控制多库多表操作             ok spring cloud soa                              ignore jvm调优                          ok 类加载机制                       ok gc机制                           ok 支付流程和注意点                  spring的加载机制                 ok tomcat加载机制                   ignore 做过的项目                       important   线程调度；多线程相关：多线程并发用到那哪些？线程数据共享；synchronize 用法，原理 ？死锁的原因，现场写了一下；（重点）    首先要了解高并发的的瓶颈在哪里？  1、可能是服务器网络带宽不够 增加网络带宽，添加CDN  2.可能web线程连接数不够 负载均衡，前置代理服务器nginx，静态资源分离到另外一个服务器  3.可能数据库连接查询上不去。 优化数据库查询语句，explain之后，找出耗时多的点，添加索引。 数据库查询优化，读写分离，分表等等  4.使用缓存，比较固定长时间少更新的solr，短期的也可以用redis，memcache    最后复制一些在高并发下面需要常常需要处理的内容:  统计的功能尽量做缓存，或按每天一统计或定时统计相关报表，避免需要时进行统计的功能。  能使用静态页面的地方尽量使用，减少容器的解析（尽量将动态内容生成静态html来显示）。  解决以上问题后，使用服务器集群来解决单台的瓶颈问题。     "},{title:"Hystrix Turbine",path:"/posts/md/part/microServices/spring%20cloud/Hystrix%20Turbine.html",strippedContent:' ### Hystrix Turbine简介  看单个的Hystrix Dashboard的数据并没有什么多大的价值，要想看这个系统的Hystrix Dashboard数据就需要用到Hystrix Turbine。Hystrix Turbine将每个服务Hystrix Dashboard数据进行了整合。Hystrix Turbine的使用非常简单，只需要引入相应的依赖和加上注解和配置就可以了。  ### 引入相应的依赖  ```xml <dependencies>     <dependency>         <groupId>org.springframework.cloud</groupId>         <artifactId>spring-cloud-starter-turbine</artifactId>     </dependency>     <dependency>         <groupId>org.springframework.cloud</groupId>         <artifactId>spring-cloud-netflix-turbine</artifactId>     </dependency>     <dependency>         <groupId>org.springframework.boot</groupId>         <artifactId>spring-boot-starter-actuator</artifactId>     </dependency> </dependencies> ```  ------    在其入口类ServiceTurbineApplication加上注解@EnableTurbine，开启turbine，@EnableTurbine注解包含了@EnableDiscoveryClient注解，即开启了注册服务。  ```java @SpringBootApplication @EnableTurbine public class ServiceTurbineApplication {     public static void main(String[] args) {         new SpringApplicationBuilder(ServiceTurbineApplication.class).web(true).run(args);     } } ```  ------    配置文件application.yml  ```yaml spring:   application.name: service-turbine server:   port: 8769 security.basic.enabled: false turbine:   aggregator:     clusterConfig: default   # 指定聚合哪些集群，多个使用","分割，默认为default。可使用http://.../turbine.stream?cluster={clusterConfig之一}访问   appConfig: service-hi,service-lucy  ### 配置Eureka中的serviceId列表，表明监控哪些服务   clusterNameExpression: new String("default")   # 1. clusterNameExpression指定集群名称，默认表达式appName；此时：turbine.aggregator.clusterConfig需要配置想要监控的应用名称   # 2. 当clusterNameExpression: default时，turbine.aggregator.clusterConfig可以不写，因为默认就是default   # 3. 当clusterNameExpression: metadata[\'cluster\']时，假设想要监控的应用配置了eureka.instance.metadata-map.cluster: ABC，则需要配置，同时turbine.aggregator.clusterConfig: ABC eureka:   client:     serviceUrl:       defaultZone: http://localhost:8761/eureka/ ```    输入监控流<http://localhost:8769/turbine.stream>'},{title:"常用sql",path:"/posts/md/db/sql.html",strippedContent:" ```shell # 备份数据库 mayday mysqldump -uroot -pAdmin123# mayday  > bk.sql   ```  "},{title:"mariadb",path:"/posts/md/db/maria.html",strippedContent:" ### maven 配置 ```xml     <dependency>         <groupId>org.mariadb.jdbc</groupId>         <artifactId>mariadb-java-client</artifactId>         <version>2.4.1</version>     </dependency> ```  ### jdbc设置  | 字段              | 值                                 | | ----------------- | ----------------------------------| | driver-class-name | org.mariadb.jdbc.Driver            | | url               | jdbc:mariadb://localhost:3306/test |    ------    ### Linux下MySQL表名不区分大小写的设置方法  1. 用root登录，打开并修改 /etc/my.cnf；在[mysqld]节点下，加入一行： lower_case_table_names=1。 2. 重启mysql服务  [^]: lower_case_table_names=1 参数缺省地在 Windows 中这个选项为 1 ，在 Unix 中为 0  "},{title:"db",path:"/posts/md/db/db.html",strippedContent:" ### 为什么数据库可以没有外键？  - 性能，影响插入、更新和删除操作的性能。数据库需要检查它是否违反数据完整性 - 传统数据，许多数据库在设计时需要存储来自旧数据库和遗留数据，这些数据可能对数据质量和完整性没有那么严格 - 全表重新加载  ###  规范  【强制】业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。  【强制】超过三个表禁止 join。需要 join 的字段，数据类型保持绝对一致；多表关联查询时， 保证被关联的字段需要有索引。   【强制】不要使用 count(列名)或 count(常量)来替代 count(*)，count(*)就是 SQL92 定义的 标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。 说明：count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行。  使用 IS NULL()来判断是否为 NULL 值。注意：NULL 与任何值的直接比较都为 NULL。    单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。  "},{title:"linux安装mariadb",path:"/posts/md/linux/linux%20%E5%AE%89%E8%A3%85mariadb.html",strippedContent:" ### 安装MariaDB  安装命令  ```shell yum -y install mariadb mariadb-server ```  安装完成MariaDB，首先启动MariaDB  ``` systemctl start mariadb ```  设置开机启动  ```shell systemctl enable mariadb ```  接下来进行MariaDB的相关简单配置  ``` mysql_secure_installation ```    初始化MariaDB完成，接下来测试登录  mysql -uroot -ppassword     ### 配置MariaDB的字符集  文件/etc/my.cnf  在[mysqld]标签下添加  ```properties init_connect='SET collation_connection = utf8mb4_unicode_ci' init_connect='SET NAMES utf8mb4' character_set_server=utf8mb4 collation-server=utf8mb4_unicode_ci init_connect='SET NAMES utf8mb4' skip-character-set-client-handshake=true ```  ------    文件/etc/my.cnf.d/client.cnf  在[client]中添加  ```properties default-character-set=utf8mb4 ```  ------    文件/etc/my.cnf.d/mysql-clients.cnf  在[mysql]中添加  ```properties default-character-set=utf8mb4 ```     全部配置完成，重启mariadb  ```shell systemctl restart mariadb ```  之后进入MariaDB查看字符集  ```sql MariaDB [(none)]> show variables like \"%character%\";show variables like \"%collation%\";  +--------------------------+----------------------------+  | Variable_name | Value |  +--------------------------+----------------------------+ | character_set_client | utf8 | | character_set_connection | utf8 | | character_set_database | latin1 | | character_set_filesystem | binary | | character_set_results | utf8 | | character_set_server | latin1 | | character_set_system | utf8 | | character_sets_dir | /usr/share/mysql/charsets/ | +--------------------------+----------------------------+  8 rows in set (0.01 sec)  +----------------------+-------------------+ | Variable_name | Value |  +----------------------+-------------------+ | collation_connection | utf8_general_ci | | collation_database | latin1_swedish_ci | | collation_server | latin1_swedish_ci | +----------------------+-------------------+  3 rows in set (0.00 sec) ```    修改DB的默认编码：  ```sql ALTER DATABASE XX_db CHARACTER SET utf8mb4; ```  "},{title:"need attention",path:"/posts/md/other/need%20attention.html",strippedContent:" #### 定义接口不规范  * hagendaza项目，定义一个HdOrderManager接口，没有继承基类`BaseManager`，无法实现`读写分离`  "},{title:"graphql介绍",path:"/posts/md/part/web/graphql/graphql%E4%BB%8B%E7%BB%8D.html",strippedContent:" ###  Query 是查询入口,  Mutation则是修改入口 * root.graphqls 是graphql 服务入口定义 * scheme.graphqls 则是 query/mutation 具体的 scheme 定义字段、类型  graphql 入口定义了, 但这只是一个描述, 我们需要实现 query/mutation中的描述(必须全部实现)  schema 一样像我的目录中的一样 AuthorResolver 这是对schema中的描述的实现  > query/mutation和普通的schema 一样, 只是它们是 graphql服务的入口, resolver实现描述遵循:  - method `name`(*args) - method is`Name`(*args) 仅支持 return boolean - method get`Name`(*args) - method getField`Name`(*args)  这是种实现, 当提供了resolver时优先使用, 其次是 class this.get`Name`方法  返回参数类型不一致，或者没有返回，需在resolver中添加    在GraphQL中，我们通过预先定义一张`Schema`和声明一些`Type`来达到上面提及的效果，我们需要知道：  * 对于数据模型的抽象是通过Type来描述的 * 对于接口获取数据的逻辑是通过Schema来描述的   ### Type  对于数据模型的抽象是通过Type来描述的，每一个Type有若干Field组成，每个Field又分别指向某个Type。  GraphQL的Type简单可以分为两种，一种叫做`Scalar Type(标量类型)`，另一种叫做`Object Type(对象类型)`。    "},{title:"RPC vs REST vs GraphQL",path:"/posts/md/part/web/graphql/RPC%20vs%20REST%20vs%20GraphQL.html",strippedContent:" ###  RPC 它是Remote Procedure Call(远程过程调用)的简称。一般基于RPC协议所设计的接口，是基于网络采用客户端/服务端的模式完成调用接口的 #### 优点 - 简单并且易于理解（面向开发者）  - 轻量级的数据载体  - 高性能  #### 缺点 - 对于系统本身耦合性高 - 因为RPC本身很简单、轻量，因此很容易造成 function explosion  关于RPC的优点其实很好理解，就是因为它性能高同时又很简单，但是我认为这是对于接口提供者来讲的（因为它的高耦合性）。  但是如果从接口调用者的角度来看，高耦合性就变成了缺点，因为高耦合意味着调用者必须要足够了解系统本身的实现才能够完成调用，比如：  - 调用者需要知道所调用接口的函数名、参数格式、参数顺序、参数名称等等 - 如果接口提供者(server)要对接口做出一些改变，很容易对接口调用者(client)造成breaking change（违背开闭原则) - 一般RPC所暴露接口仅仅会暴露函数的名称和参数等信息，对于函数之间的调用关系无法提供，这意味着调用者必须足够了解系统，从能够知道如何正确的调用这些接口，但是对于接口调用者往往不需要了解过多系统内部实现细节  --- ### REST 当前REST风格的API架构方式已经成了主流解决方案了，相比较RPC，它的主要不同之处在于，它是对于资源(Resource)的模型化而非步骤(Procedure)。 #### 优点 - 对于系统本身耦合性低，调用者不再需要了解接口内部处理和实现细节 - 重复使用了一些 http 协议中的已定义好的部分状态动词，增强语义表现力 - API可以随着时间而不断演进 #### 缺点 - 缺少约束，缺少简单、统一的规范 - 有时候 payload 会变的冗余(overload)，有时候调用api会比较繁琐(chattiness) - 有时候需要发送多条请求已获取数据，在网络带宽较低的场景，往往会造成不好的影响  REST的优点基本解决了RPC中存在的问题，就是解耦，从而使得前后端分离成为可能。接口提供者在修改接口时，不容易造成breaking-change，接口调用者在调用接口时，往往面向数据模型编程，而省去了了解接口本身的时间成本。  但是，我认为REST当前最大的问题在于虽然它利用`http`的动词约束了接口的暴露方式，同时增强了语义，但是却没有约束接口如何返回数据的最佳实践  ---  ### GraphQL GraphQL是近来比较热门的一个技术话题，相比REST和RPC，它汲取了两者的优点，即不面向资源，也不面向过程，而是面向数据查询(ask for exactly what you want)。同时GraphQL本身需要使用强类型的Schema来对数据模型进行定义，因此相比REST它的约束性更强。  #### 优点 - 网络开销低，可以在单一请求中获取REST中使用多条请求获取的资源 - 强类型Schema（约束意味着可以根据规范形成文档、IDE、错误提示等生态工具） - 特别适合图状数据结构的业务场景（比如好友、流程、组织架构等系统） #### 缺点 - 本身的语法相比较REST和RPC均复杂一些 - 实现方面需要配套 Caching 以解决性能瓶颈 - 对于 API 的版本控制当前没有完善解决方案（社区的建议是不要使API版本化） - 仍然是新鲜事物，很多技术细节仍然处于待验证状态 首先值得肯定的是，在某些程度上确实解决了REST的缺点所带来的问题,GraphQL所带来的好处，大部分是对于接口调用者而言的，但是实现这部分的工作却需要接口提供者来完成。"},{title:"MapStruct",path:"/posts/md/tool/MapStruct.html",strippedContent:' ### MapStruct 一个 Java 实体映射工具 一个成熟的工程中，尤其是现在的分布式系统中，应用与应用之间，还有单独的应用细分模块之后，DO 一般不会让外部依赖，对象与对象之间的互相转换，就需要有一个专门用来解决转换问题的工具   ###  maven 依赖  ```xml <properties>     <mapstruct.version>1.2.0.Final</mapstruct.version> </properties>  <dependencies>     <dependency>       <groupId>org.mapstruct</groupId>       <artifactId>mapstruct-jdk8</artifactId>       <version>${mapstruct.version}</version>     </dependency>     <dependency>       <groupId>org.mapstruct</groupId>       <artifactId>mapstruct-processor</artifactId>       <version>${mapstruct.version}</version>     </dependency> </dependencies> ```      ```java @Mapper(componentModel = "spring") public abstract class PesonMapper {     public PersonModel mapEighteen( Person entity) { \t  if (entity.getName.equals(18)) { \t\t   return map(entity);       }    }; \t    @Mapping(target = "personName", source = "name")    @Mapping(target = "hand",  ignore = true)    protected abstract PersonModel map( Person entity);     protected abstract  List<PersonModel > map(List< Person> entity);  } ```  '},{title:"vpn",path:"/posts/md/tool/vpn.html",strippedContent:" ### MTProxy  ```shell wget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/mtproxy.sh && chmod +x mtproxy.sh && bash mtproxy.sh ```    ### Brook  ```shell ## https://github.com/txthinking/brook wget https://github.com/txthinking/brook/releases/download/v20190601/brook  # chmod chmod u+x brook  ### Shadowsocks nohup brook ssserver -l :3072 -p Admin123# > /dev/null 2>&1  &   # brook server nohup brook server -l :2222 -p Admin123#  > /dev/null 2>&1  &  ```    ### youtube-dl  ```shell  # youtube wget http://www.youtube-dl.org/downloads/latest/youtube-dl chmod u+x youtube-dl  # 需要安装yasm # wget http://www.tortall.net/projects/yasm/releases/yasm-1.3.0.tar.gz # tar -zxvf yasm-1.3.0.tar.gz # cd yasm-1.3.0 # ./configure # make && make install  # install ffmpep # wget https://ffmpeg.org/releases/ffmpeg-4.1.3.tar.bz2 # tar -zxvf ffmpeg-4.1.tar.gz # cd ffmpeg-4.1 # ./configure --prefix=/usr/local/ffmpeg # make && make install  #vi /etc/profile #在最后PATH添加环境变量： PATH=$PATH:/usr/local/ffmpeg/bin export PATH  #保存退出  source /ect/profile   设置生效 ```    ```shell #blog nohup mvn spring-boot:run  > /dev/null 2>&1 & ```  "},{title:"阿里云oss缩略图",path:"/posts/md/tool/oss.html",strippedContent:" #### OSS是使用通过URL尾部的参数指定图片的缩放大小    图片路径后面拼接如下路径：  ?x-oss-process=image/[处理类型],x_100,y_50[宽高等参数]    ?x-oss-process=image/resize,m_fill,h_高度,w_宽度,limit_0    示例：    原图：    http://qunxianghui-upload.oss-cn-hangzhou.aliyuncs.com/upload/image/20180829/84cb48ea3923c827481787b8877f9260.jpeg    缩略图：（注意：复制下面链接到浏览器中访问，直接点击可能后面参数带不过去）    http://qunxianghui-upload.oss-cn-hangzhou.aliyuncs.com/upload/image/20180829/84cb48ea3923c827481787b8877f9260.jpeg?x-oss-process=image/resize,m_fill,h_100,w_200"},{title:"spring事务",path:"/posts/md/part/spring/spring%E4%BA%8B%E5%8A%A1.html",strippedContent:" ------    ### Spring声明式事务七种传播行为  - REQUIRES_NEW：不管是否存在事务，该方法总会为自己发起一个新的事务。如果方法已经运行在一个事务中，则原有事务挂起，新的事务被创建。   - NESTED：如果一个活动的事务存在，则运行在一个嵌套的事务中。如果没有活动事务，则按REQUIRED属性执行。它使用了一个单独的事务，这个事务拥有多个可以回滚的保存点。内部事务的回滚不会对外部事务造成影响。它只对`DataSourceTransactionManager`事务管理器起效。 - REQUIRED：业务方法需要在一个事务中运行，如果方法运行时，已处在一个事务中，那么就加入该事务，否则自己创建一个新的事务。**这是spring默认的传播行为**。 - MANDATORY：该方法只能在一个已经存在的事务中执行，业务方法不能发起自己的事务。如果在没有事务的环境下被调用，容器抛出异常。 - SUPPORTS：该方法在某个事务范围内被调用，则方法成为该事务的一部分。如果方法在该事务范围外被调用，该方法就在没有事务的环境下执行。 - NOT_SUPPORTED：声明方法不需要事务。如果方法没有关联到一个事务，容器不会为他开启事务，如果方法在一个事务中被调用，该事务会被挂起，调用结束后，原先的事务会恢复执行。 - NEVER：该方法绝对不能在事务范围内执行。如果在就抛异常。只有该方法没有关联到任何事务，才正常执行。"},{title:"spring boot 运行方式",path:"/posts/md/part/spring/springBoot.html",strippedContent:" #### springboot 运行    ``` shell # jar方式运行   -D 参数必须在jar前面指定 java -jar -Dserver.port=8081 spring-boot-test-service-0.0.1-SNAPSHOT.jar  # spring-boot plugin 运行 mvn spring-boot:run -Dspring-boot.run.arguments='--spring.profiles.active=pro'  #  mvn spring-boot:run -Dspring-boot.run.profiles=pro ```    ####  springboot中的配置文件server.context-path不起作用  因为spring boot版本问题导致的！！现在用的比较新的版本在2.0以上！以前是1.0-2.0之间的.server.context-path=/XXXXX  ```properties server.servlet.context-path=/XXXXX  # 2.0以上  server.context-path=/XXXXX          #  2.0以下 ```    ------    #### springboot无法完成变量从pom到.properties文件自动替换的问题  我在maven的pom文件中进行了多环境变量配置，引用了maven-resources-plugin，在application.properties文件中通过以下配置指定不同环境下的配置文件，  ```properties spring.profiles.active = ${profiles.active} ```  但是${profiles.active}无法从pom文件中获取变量值替换  > 由于`${}`方式会被maven处理。如果你pom继承了`spring-boot-starter-parent`，Spring  > Boot已经将maven-resources-plugins默认的`${}`方式改为了`@@`方式，如`@name@`  如果还想继续使用${}占位符方式，只需要在pom文件中加上下面配置即可：  ```xml <plugin>     <artifactId>maven-resources-plugin</artifactId>     <configuration>         <encoding>utf-8</encoding>         <useDefaultDelimiters>true</useDefaultDelimiters>     </configuration> </plugin> ```  ```java ## tag.tagid，不能使用 #{tag.tagid} @Cacheable(value = ARTICLES_CACHE_NAME, key = \"'findArtileByTag'+#tag.tagId+#page+#limit+#status\") ```    较新版的Spring Boot取消了@`SpringApplicationConfiguration`这个注解，用`@SpringBootTest`就可以了"},{title:"endPoint",path:"/posts/md/part/spring/springboot/endPoint.html",strippedContent:" ### Endpoint SpringBoot的Endpoint主要是用来监控应用服务的运行状况，并集成在Mvc中提供查看接口  ---  ### 内置Endpoint * HealthEndpoint 监控dist和db的状态 * MetricsEndpoint 监控内存与gc的状况  "},{title:"spring",path:"/posts/md/part/spring/spring.html",strippedContent:' # @Bean注解修饰带参数方法时，参数取值  ```java @Bean \tpublic RabbitAdmin rabbitAdmin(ConnectionFactory connectionFactory){ \t\tSystem.out.println(String.format("-----------getRabbitAdmin:%s", connectionFactory.hashCode())); \t\treturn new RabbitAdmin(connectionFactory); } ```  如上，有参数connectFactory，若spring容器中只有一个ConnectionFactory 类型的bean，则不论参数取名为何都是按类型取bean ConnectionFactory 为参数，若有多个则参数取名必须为多个bean中的一个，否则报错。      spring：容器 核心：依赖注入和控制反转 Spring有两个核心接口：BeanFactory和ApplicationContext bean之间不用new object，解耦。由spring容易管理。在需要时，注入 @autowire @component @controller @service等注解，通过scan标签扫描。 管理bean和bean，模块和模块之间的关系。  '},{title:"spring cloud介绍",path:"/posts/md/part/microServices/spring%20cloud/spring%20Cloud%E4%BB%8B%E7%BB%8D.html",strippedContent:" ### 服务发现组件：eureka  eureka client注册到eureka服务端上，不管服务提供者还是服务消费者都要注册。 eureka服务端和客户端有心跳机制，默认30秒。90秒没有收到，就会剔除掉这个客户端。 服务消费者客户端上有服务注册表缓存，eureka服务端down之后，也能找到服务提供者。  ------    ### 客户端负载均衡组件：ribbon  三种方式：`轮循`，`随机`，`根据响应时间加权` 默认策略是`轮循`。 可以自定义 eureka包含有ribbon的jar包  ------    ### feign：命名式的http client  整合了ribbon和eureka    支持springMVC的注解 包含feign encoder ，feign decoder，feign contract  ------    ### hystrix：断路器和超时机制的组件  没有保护应用会导致雪崩效应 超时机制 断路器模式：依赖的服务有大量超时，不去请求，快速失败 断路器状态：关闭，打开，断开 打开，直接返回状态不可用 半开，尝试请求，成功率达标，断路器关闭，反之打开 关闭，正常请求  1.监控，总共请求多少次，有多少失败，失败率达到标准，断路器打开 2.断路器状态 3.半开时，分流 4.自我修复，断路器状态切换  当对特定服务呼叫，hystrix默认5秒钟失败20次，打开断路器 回退机制，fallback，可以由开发人员提供 health indicator健康指标 hystrix.stream 监控  turbine 监控整个集群  ------    zuul 实现比较好的api gateway 反向代理所有注册在eureka上的服务  Sidecar 支持使用其他语言的微服务  ------    ### spring cloud config统一管理微服务配置的组件  集中管理 动态调整 不同环境不同配置 自动刷新 config server 连上GIT   config client 获取git上的配置  ------    spring cloud bus 基于mq trace追踪      "},{title:"eureka",path:"/posts/md/part/microServices/spring%20cloud/eureka.html",strippedContent:" #### EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY'RE NOT. RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUST TO BE SAFE. ```properties #一般出现此模式时，服务返回错误。即如果真实的服务已经Down掉，但在注册中心界面服务却一直存在，且显示为UP状态，关掉自我保护模式 eureka.server.enable-self-preservation = false ```  "},{title:"thinking",path:"/posts/md/other/thinking.html",strippedContent:" - 不断增值自己，拥有更多选择权 - 互联网没有舒适圈，止步不前便是退步 - 学习是面对竞争、度过中年危机的最好方法    永远为`下周离职`做准备  "},{title:"eq",path:"/posts/md/other/eq.html",strippedContent:" - 感知他人情绪的能力。 - 控制自己情绪的能力。 - 目标和行为的高度统一  感受到对方的表情变化，并及时调整自己的说话思维方式，这才是正确的反馈"},{title:"适应社会而磨平棱角吗",path:"/posts/md/other/%E9%80%82%E5%BA%94%E7%A4%BE%E4%BC%9A%E8%80%8C%E7%A3%A8%E5%B9%B3%E6%A3%B1%E8%A7%92%E5%90%97.html",strippedContent:" #### 如果成长就是向世界妥协，你愿意为了适应社会而磨平棱角吗？    我也曾经以为我在妥协，后来发现我只是自说自话地感动自己罢了，就像你长大了明白你是两性生殖产生的，而不是像小时候妈妈告诉你，你是路边上捡来的。  这叫妥协吗……？  简单的来讲，套用逼乎模版，我可以说：（太长不看版）  1.先问是不是，再问为什么。成长是认识世界的过程，一草一木皆是世界，臭水沟是世界，乌托邦也是世界，小孩子可能只见识到世界的5%，而20岁的你可能见识到了10%，等四十不惑的时候可能到了25%，当我们悲伤逆流成河地说自己跟世界“妥协”了，你有没有想过，  这个宾语，所谓“世界”，你真的知道是什么吗？到底跟谁妥协的呢？美国国家妥协局？中国人民妥协部？你是在遍历了世界所有元素之后，然后说，这就是世界，我真的看透了，所以我不得不为了生存而修改自己的初心？  2.以大部分人的认知阅历水平，是没资格谈论自己的所谓“初心”被抹平的。你都不知道自己到底想要啥，还谈个锤子的初心？就像全中国你能够抓出来100万个创业者，连街边卖地瓜的都算，他也有梦想，他也会振振有词告诉你怎么从卖地瓜到卖坦克走向人生巅峰。  但这不意味着他真的拥有或者配拥有一个普遍意义上他能够驾驭的比较合理的梦想，梦想是个宏大叙事，而平头百姓烫头百姓很难说自己有资格探讨宏大叙事。就像你不能说自己看了本《时间简史》就说自己算是科学家了，你这充其量是个科晓家，少看点郭德纲吧。  3.私以为，很多人有这种疑问，还是因为过于“顾影自怜”+“对世界认识不到位”。就像第一点探讨的，世界就是世界，你也是世界的一部分，它不是割裂的，不是随着18岁生日的蜡烛吹灭，突然骤然忽然莫名其妙地就巨变了质变了。  你的所谓初心，类比一下，就好比windows系统，你中学是windows98，高中是windowsXP，大学是win8，等到成家立业可能变成了win10，难道你告诉我，“当年我像win98一样简陋的初心，当初我想当科学家，后来我成绩不好上了专科，我的梦想破灭了，我为了生存不得不跟世界妥协！”这不是很可笑吗？之所以有人能当科学家，是因为他们有资格当，而不仅仅是因为他们想当，你想当，那你就拿出证据。  win10之所以比前几版好使，不是它跟谁妥协了，是它更成熟了，更完善了，更适应时代了，你可以说98和XP也有很多独到之处，但是事实上，他们就是落伍了，他们也并不因为你的情怀，而变得可以亘古不变价值永恒，如果你觉得自己的初心是不可更改不可妥协的，我觉得90%的可能是你太自恋。记住，情怀，绝大多数时候，都是自恋，难道不是吗？  你的初恋，你念念不忘，但是关我屁事呢？我会对她/他高看一眼吗？不会。  你的梦想，你不能平息，但是我凭什么就得理解你呢？你爱干嘛干嘛与我无关啊。  先看看题主的问题：  在成人世界里，一直保持一颗初心和童真，怕是一件非常难的事儿吧。 > 随着逐渐年长，人们总是在不停地向现实妥协，在守护心灵中的理想世界和接受世俗融入社会之间，大部分人都被迫选择了后者，世界给这种举动起了一个很好听的名儿：成长。 > 于是成长在成人世界里的含义，往往都是残酷的。 > 有的时候你会羡慕那些一直天真乐观的大孩子，因为他们就像年轻时候的自己；也会心疼那些保持初心却饱受现实摧残的「边缘人士」，也想要劝他们跟现实和解。 > 大多数时候，不是我们选择「自我阉割」，而是被生活「阉割」；很多经历促使你变得理性克制近乎冷淡、迟钝抗压近乎麻木，平滑老道近乎世故，因为这才是现在这个社会的生存之道。 > 如果可以选择的话，你会选择接受现实从而活的容易一些，还是宁愿跌跌撞撞也要永远年轻热泪盈眶?  我是很有资格探讨这种问题的，初心，初恋，热血，激情，本愿，这些高大上的词汇，大家都有，我更有。 曾经中学的我，也是非常文艺的，我敢说比很多自诩文艺青年的人都更有资格，毕竟，那些熟读唐诗三百首的人，大概还是不如我这种写了诗歌300首的有资格说自己文艺吧，你行你也写呗，对吧。短篇也写了十几篇，长篇大概开了两个坑，我的理想就是去当个写手，甚至作家。我知道这条路很难，但是我想，韩寒，郭敬明，蒋方舟，这些人不都或多或少跟我有点像，他们能够成功，我为什么不能？  当然，这都不重要，我只是想证明，我确实有自己的初心，我也有点资格说自己有这个初心。  后来呢？我当然没有那么冲动，我没有辍学，我还是坚持学习，同时笔耕不辍，想着等我高考完，立马开始投稿，各种投，我写的也杂，我写诗歌，也写短篇小说，写长篇校园小说（类似于韩寒那种），也写科幻小说，我觉得自己还是挺有天赋的吧，我也觉得自己是独特的。  显然，我自然是四处碰壁，投稿别说拒稿，人家根本不回复你，你都以为自己是不是没有发过去。  另一方面，高中的时候，我一直是我们班里的前五名，万年掉不出去，我只要不自暴自弃，怎么都是前五，第一倒是少有，第二第三考过好几次，我觉得自己还是学习蛮好的吧，我觉得自己既文艺，又兼顾学业，多厉害啊。所以我觉得，我的前途是充满未知却金光灿烂的，我可以成为学霸型写手，以后那真是风光无限，美女如云……  然而？  投稿石沉大海，而且随着我在网上看各种文章，逛文学类贴吧，找所谓文字工作室（网上的小团体，收稿子卖钱那种），我才了解到，原来文字圈是这样，别说扬名立万了，现在出版社本身就不景气，你想出书也容易，几万块就可以出，然而意义何在？你说你想出名？不好意思，本来现在看书的就少，推广成本你没个上百万你根本推不出去，而且，文字圈毕竟是讲究圈子的，就像娱乐圈一样，不是你够努力够砸钱就能够混成当成炸子鸡的，你需要贵人伯乐，你需要切入点好机会……  这些，在最初形成我的初心的时候，我是都不知道的，所以赖谁呢？赖世界吗？  高考，更有意思了，我这个全班名列前茅的人只高了一本线一分，根本上不了什么正经的一本，我之前也知道我们班不是好班，但是谁知道到底放在高考的尺度下算是什么水平呢，对吧？  最后我们班一共才有五六个人过了一本线，最好的一个才去了青岛大学而已，这就是赤裸裸的世界，我的初心自然被打破了。  还是那个问题，这赖谁呢？赖世界没有给我一个我以为的预期吗？  难道这些不是世界本来的面目吗？投稿很难，难道不是一直都那样吗，出版业不景气，你自己不知道你赖谁呢？高考难，难道不是全中国人都该知道的吗，你以为自己学习很好，那又如何呢？大家都想考北大清华所以大家都该上吗？  因为你不知道，所以你就非常唯心主义的觉得，不对，这跟我想的不一样，所以世界错了，你们错了， 你们要按我说的改！  您是上帝吗？  再来看题主的话：  > 随着逐渐年长，人们总是在不停地向现实妥协，在守护心灵中的理想世界和接受世俗融入社会之间，大部分人都被迫选择了后者，世界给这种举动起了一个很好听的名儿：成长。  现实并没有变化，变化的是你而已，世俗也一直就是那样，只是你一直蹲在新手村看不见而已，大部分人当然选择后者，不然呢？就你特殊可以不去适应世界是吗？ 进化论还不明白吗？尼安格特人怎么灭绝的？是因为他们不够强大，被我们的祖先给竞争灭绝了，你不想融入世俗，您就接受灭绝就好了，你有今天的这个肉体，全仰赖你的老祖宗积极入世。  > 有的时候你会羡慕那些一直天真乐观的大孩子，因为他们就像年轻时候的自己；也会心疼那些保持初心却饱受现实摧残的「边缘人士」，也想要劝他们跟现实和解。  一直的乐观天真，到底是一种**不自知的愚昧**，还是一种大无畏的乐观主义？  > 大多数时候，不是我们选择「自我阉割」，而是被生活「阉割」  文艺青年总喜欢说这种玄了吧唧的废话，我当年就是这样——自我阉割也好，被别人阉割也好，本质上是为了融入世界，你完全可以不融入，死掉就好咯，就这么简单。何况，所谓“自我阉割”，到底是自己越来越有逼数，越来越不那么狂妄愚昧，还是真的你一个天选之子不得不屈服于浮尘俗世？  丑小鸭不屈服于群体，那是因为人家基因里就是天鹅，你要是鸭子怎么办？  换句话说，你是选择主动认错，还是被别人揍一顿之后被教做人？  > 很多经历促使你变得理性克制近乎冷淡、迟钝抗压近乎麻木，平滑老道近乎世故，因为这才是现在这个社会的生存之道。  很多人以为变得理性就是变得迟钝，变得博学就是变得麻木，不好意思，我们家是县城的，我们家是做生意的，我从小到大就见识了太多底层家庭，底层人民，我还算是知道普罗大众的精神面貌和认知水平的，从农村的工人大爷，到城里的穷苦泼妇，从学校的天真中产，到大学的官富二代。  难道天真就意味着不迟钝？难道愚昧就意味着活力四射？  就像当年那个充满激情，满脑子未来憧憬的自己，我不知道投稿有多难，我不知道自己作品水平没那么好，我不知道自己高考就那么回事，我甚至也不知道自己到底多丑多帅……  所以当年那个我，就是所谓“不冷淡，不麻木，不圆滑不世故”的好青年了？  你当然可以说当年的自己是充满热血的，但是这不意味着中二少年就是值得敬佩的，这充其量，是人生的一个阶段，就像小处男夜夜幻想着美女的胴体，然后过了几年有了孩子反而性冷淡了，你难道还能分出个优劣来？你就应该一辈子都跟个小处男一样，像个泰迪一样看着谁都想日？这就是青春永驻了？这就是有意义的人生？  > 如果可以选择的话，你会选择接受现实从而活的容易一些，还是宁愿跌跌撞撞也要永远年轻热泪盈眶?  如果说我们有的选择的话，大概这句话还有点意义， 就像当初的我，我可以选择留在国内，按部就班来毕业找工作，考国家电网或者公务员，也可以选择出国留学充满未知和机遇，走一条比较艰险的路。  但是要说“跌跌撞撞也要永远年轻热泪盈眶”这就太符合我一开始说的，“自我感动”“不自知不自觉”“顾影自怜”，不要觉得我无情，毕竟，本人自己就非常中二过，我也有资格说自己追梦吧，你们有本事也写几百首诗然后投稿啊挣扎啊，别光口嗨啊对吧？我好歹真的去做了。  所以恰恰因为这样，我才认识到自己当初多么狂妄，多么自恋，多么无知。  这个世界不是给你准备的，你不是主角，你只是75亿人里面的一个罢了。  成长本质上就是越来越认识这个世界的面貌，越来越熟悉里面的规则，你会觉得这些东西残酷，那是因为，当你在父母的庇护下的时候，你不需要考虑这些——但不意味着这些不存在，因为当时——是你的父母在考虑这些，不是你。当你成为父母的时候，你的孩子也会一样，心安理得地造梦，觉得世界是他自己的，所有人都该围着他转，有这种心态这很正常，但是你不能一辈子都这样，这也不是对的。  所以总而言之，我们幻想出一个“棱角”来取悦自己的内心，让自己以为曾经，自己也是个勇士也是英雄，只是俗世逼自己一个大人物妥协，这个心态很常见，但是它是不靠谱的，你也根本就是普普通通的人罢了，你根本没有什么牛逼闪闪的“棱角”，被什么巨兽恶魔所打磨，你只是越来越有逼数了，越来越认识到自己在这个社会里的位置，世界到底是什么样子，你修正自己的航线，是为了不至于撞冰山撞死，而不是什么伟大的“壮士断腕”，  说难听点，你当年的梦想，一文不值。就像我当年的梦想，一文不值，但是这并不妨碍我继续前进，不然，也没有我今天知乎上的这个答案对吧？ "},{title:"缩写",path:"/posts/md/other/%E7%BC%A9%E5%86%99.html",strippedContent:" # UAT SIT QAS DEV PET    - `SIT`: System Integrate Test的缩写，即系统整合测试  - `QAS`: Quality Assurance system　质量保证  - `DEV`: Development 开发  - `PET`: Performance Evaluation Test　性能测试  "},{title:"linux安装软件",path:"/posts/md/linux/linux%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6.html",strippedContent:" ### 设置交换分区  SpringBoot多项目部署项目运行被killed解决办法，没有分配swap空间  ```shell #创建/home/swap这么一个分区文件。文件大小是512000个block，一般情况下1个block为1k，所以这里空间是1024M，一般是物理内存的2倍。 dd if=/dev/zero of=/home/swap bs=1024 count=1024000  #将这个分区变成swap分区。 /sbin/mkswap /home/swap  #使用swap分区，使其生效 /sbin/swapon /home/swap  #查看swap分区大小 free -m  # 系统重启后swap分区会还原，解决办法：修改/etc/fstab文件，增加一行 /home/swap           swap                 swap       defaults              0 0 ```    ### 安装openJdk  ```shell ## 必须安装带devel版本（完整jdk） yum -y install java-1.8.0-openjdk.x86_64 java-1.8.0-openjdk-devel.x86_64 ```    ### 安装nginx    ```shell # first install yum-utils yum install yum-utils ```  To set up the yum repository, create the file named `/etc/yum.repos.d/nginx.repo` with the following contents:  ```properties [nginx-stable] name=nginx stable repo baseurl=http://nginx.org/packages/centos/$releasever/$basearch/ gpgcheck=1 enabled=1 gpgkey=https://nginx.org/keys/nginx_signing.key  [nginx-mainline] name=nginx mainline repo baseurl=http://nginx.org/packages/mainline/centos/$releasever/$basearch/ gpgcheck=1 enabled=0 gpgkey=https://nginx.org/keys/nginx_signing.key ```  ```shell # By default, the repository for stable nginx packages is used. If you would like to use mainline nginx packages, run the following command yum-config-manager --enable nginx-mainline  # To install nginx, yum install nginx ```      ### vmware centos网络不通  编辑 /etc/sysconfig/network-scripts/ifcfg-ensXXXX  ```properties #修改如下值 BOOTPROTO=dhcp ONBOOT=yes  #重启网络服务 service network restart ```      >目前在官网下载低于jdk1.8的java jdk的时候需要登陆，这边分享一个账号，方便下载  2696671285@qq.com  密码：Oracle123 "},{title:"shell",path:"/posts/md/linux/shell.html",strippedContent:" 单引号字符串的限制：  - 单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的； - 单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。"},{title:"centos设置",path:"/posts/md/linux/centos.html",strippedContent:" #### 设置静态IP  修改/etc/sysconfig/network-scripts/ifcfg-ens33  文件  ```properties BOOTPROTO=static IPADDR=192.168.85.135 GATEWAY=192.168.85.2 NETMASK=255.255.255.0 DNS1=192.168.85.2 ``` ---  #### Linux下查看网关方法： ```shell route -n  ip route show  #第一行就是自己的默认网关 traceroute www.prudentwoo.com -s 100   netstat -r  more /etc/network/interfaces  #Debian/Ubuntu Linux  more /etc/sysconfig/network-scripts/ifcfg-eth0 #Red Hat ``` ---   #### 无法访问外网 ```shell #修改文件   /etc/sysconfig/network-scripts/ifcfg-ens33  #ONBOOT=no改为yes，确认BOOTPROTO=dhcp  #然后重启网络服务 systemctl restart network ``` ---   #### 如果报未找到ifconfig命令   ```shell #安装net-tools yum install net-tools  -y ```"},{title:"peerDNS",path:"/posts/md/linux/peerDNS.html",strippedContent:" 先认识一下这三个配置文件：  ```shell /etc/hosts #：这个是最早的 hostname 对应 IP 的存档； /etc/resolv.conf #：当需要解析域名时，读取该文件获得DNS 服务器 IP； /etc/nsswitch.conf#：这个档案『决定』先使用 /etc/hosts 还是 /etc/resolv.conf 的设定！ ```  当电脑要访问一个域名时，要将域名翻译成IP地址。  这个过程通常会先访问/etc/hosts，看本地是否有对应的hostname -- IP记录。  如果没有就去查询DNS服务器，通过/etc/resolv.conf 得到dns服务器地址。  当在eth接口启用DHCP后，本地resolv.conf文件将被修改，resolv.conf文件中的DNS地址将被改为从DHCP获取到的地址。这种从DHCP获得的DNS即是Peer DNS。  启用DHCP后即便修改/etc/resolv.conf，不久又恢复成原样。如何解决这个问题？此时，你得要在 /etc/sysconfig/network-scripts/ifcfg-eth0 等相关档案内，增加一行：『PEERDNS=no』，然后重新启动网络即可。  "},{title:"java8",path:"/posts/md/langu/jdk/java8.html",strippedContent:' #### Optional    类主要解决的问题是臭名昭著的空指针异常（`NullPointerException`）   ##### orElse与orElseGet  of中值不为空，则orElseGet不执行函数，而orElse一定会执行的  ```java static String B() {   System.out.println("B()...");   return "B"; }  public static void main(final String... args) {   System.out.println(Optional.of("A").orElse(B()));   System.out.println(Optional.of("A").orElseGet(() -> B()));   System.out.println(Optional.ofNullable(null).orElseGet(() -> B())); }  //执行结果 B()... A A B()... B ```  ------  #### map  ```java Optional<String>  name=Optional.of("Huang Dahui"); Optional<String> upperName = name.map(String::toUpperCase);  //执行结果：  HUANG DAHUI ```  #### Predicate  ```java public class Java8Tester {    public static void main(String args[]){       List<Integer> list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);                // Predicate<Integer> predicate = n -> true       // n 是一个参数传递到 Predicate 接口的 test 方法       // n 如果存在则 test 方法返回 true                System.out.println("输出所有数据:");                // 传递参数 n       eval(list, n->true);                // Predicate<Integer> predicate1 = n -> n%2 == 0       // n 是一个参数传递到 Predicate 接口的 test 方法       // 如果 n%2 为 0 test 方法返回 true                System.out.println("输出所有偶数:");       eval(list, n-> n%2 == 0 );                // Predicate<Integer> predicate2 = n -> n > 3       // n 是一个参数传递到 Predicate 接口的 test 方法       // 如果 n 大于 3 test 方法返回 true                System.out.println("输出大于 3 的所有数字:");       eval(list, n-> n > 3 );    }         public static void eval(List<Integer> list, Predicate<Integer> predicate) {       for(Integer n: list) {          if(predicate.test(n)) {             System.out.println(n + " ");          }       }    } } ```  #### stream ```java List<String> spuCodes = itemDetails.stream().map(ItemListByKeyOVO.ItemDetail::getCode).collect(Collectors.toList()); ```  '},{title:"高并发",path:"/posts/md/%E7%9F%A5%E8%AF%86%E7%82%B9/%E9%AB%98%E5%B9%B6%E5%8F%91.html",strippedContent:" ## 首先要了解高并发的的瓶颈在哪里？    ### 前端性能优化技术  1. 前端负载均衡: DNS，CDN  2. 减少前端链接数: 把js打成一个文件，把css也打成一个文件，把图标也打成一个文件，用css分块展示。把链接数减到最低。  3. 减少网页大小增加带宽:尽量少用图片  4. 前端页面静态化: 静态化一些不常变的页面和数据  5. 优化查询: redis缓存  ---  ### 后端性能优化技术  1. 数据冗余: 减少表连接这样的开销比较大的操作，优化sql语句  2. 数据镜像: 把一台数据库的负载均分到多台上，同时又保证了数据一致性(Oracle的SCN)。最重要的是，这样还可以有高可用性，一台废了，还有另一台在服务 3. 数据分区     * 把数据把某种逻辑来分类: 把一张表拆成多张有一样的字段但是不同种类的表    * 把数据按字段分，也就是竖着分表: 把一些不经常改的数据放在一个表里，经常改的数据放在另外多个表里。把一张表变成1对1的关系    * 平均分表: 通过主键ID的范围来分表。    * 同一数据分区: 把同一商品的库存值分到不同的服务器上，然后负载均衡 4. 后端系统负载均衡: 需要一个任务分配系统，其还能监控各个服务器的负载情况。 5. 异步、 throttle 和 批量处理: 把一堆基本相同的请求批量处理,大家同时购买同一个商品，没有必要你买一个我就写一次数据库，完全可以收集到一定数量的请求，一次操作一个是作业量，另一个是timeout  "},{title:"jvm参数",path:"/posts/md/langu/jdk/jvm.html",strippedContent:" ### Java 堆内存开关  |      VM 开关      | VM 开关描述                                                  | | :---------------: | :----------------------------------------------------------- | |       -Xms        | 设置JVM启动时堆的初始化大小。                                | |       -Xmx        | 设置堆最大值。                                               | |       -Xmn        | 设置年轻代的空间大小，剩下的为老年代的空间大小。             | |    -XX:PermGen    | 设置永久代内存的初始化大小。                                 | |  -XX:MaxPermGen   | 设置永久代的最大值。                                         | | -XX:SurvivorRatio | 提供Eden区和survivor区的空间比例。比如，如果年轻代的大小为10m并且VM开关是-XX:SurvivorRatio=2，那么将会保留5m内存给Eden区和每个Survivor区分配2.5m内存。默认比例是8。 | |   -XX:NewRatio    | 提供年老代和年轻代的比例大小。默认值是2。                    |        ### Tomcat运行jvm参数  ```shell -Xms256m -Xms512m -XX:MaxNewSize=256m -XX:MaxPermSize=256m ```      "},{title:"file",path:"/posts/md/langu/jdk/jdk%20File.html",strippedContent:" ```java File file = new File()  //文件名，包含后缀，但不包含路径  //   /root/11.jpg   则显示 11.jpg   file.getName()      // 文件路径  完整的绝对路径 //   /root/11.jpg   则显示 /root/11.jpg file.getPath()      // 重命名   newPath新目标文件绝对路径     file.renameTo(new File(newPath)); ```"},{title:"java8多线程",path:"/posts/md/langu/jdk/java8%20%E5%A4%9A%E7%BA%BF%E7%A8%8B.html",strippedContent:" ### CompletableFuture 可以看到，thenAccept和thenRun都是无返回值的。如果说thenApply是不停的输入输出的进行生产，那么thenAccept和thenRun就是在进行消耗。它们是整个计算的最后两个阶段。 同样是执行指定的动作，同样是消耗，二者也有区别：  thenAccept接收上一阶段的输出作为本阶段的输入 　　  thenRun根本不关心前一阶段的输出，根本不不关心前一阶段的计算结果，因为它不需要输入参数"},{title:"java",path:"/posts/md/langu/jdk/java.html",strippedContent:" #### 集合排序  ```java // 默认是升序 Collections.sort;  // 降序 Arrays.sort(strArray, Collections.reverseOrder()); ```  "},{title:"docker常用命令",path:"/posts/md/docker/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html",strippedContent:' `Docker` 是一个开源的轻量级容器管理`引擎`，可以轻松的为任 何应用创建一个轻量级的、可移植的、自给自足的容器  - 简化程序 - 避免选择恐惧症 - 节省开支   #### **创建镜像**  ```shell  docker commit -m " add hdh.log file" -a="hdh"  48f1dac1ceb9  mqiy/ubuntu:v0.01 # -m:提交的描述信息 # -a:指定镜像作者 # 48f1dac1ceb9：容器ID # mqiy/ubuntu:v0.01:指定要创建的目标镜像名   v0.01 tag  # 执行新建镜像  docker run -t -i mqiy/ubuntu:v0.01 ```  #### 启动容器  ```shell docker run ubuntu:15.10   --name hdh0.01  /bin/echo "Hello world" # docker: Docker 的二进制执行文件。 # run:与前面的 docker 组合来运行一个容器。 # ubuntu:15.10指定要运行的镜像，Docker首先从本地主机上查找镜像是否存在，如果不存在，Docker 就会从镜像仓库Docker Hub  下载公 # 共镜像 # /bin/echo "Hello world": 在启动的容器里执行的命令  # 以上命令完整的意思：Docker 以 ubuntu15.10 镜像创建一个新容器，然后在容器里执行 bin/echo "Hello world"，然后输出结果。 # -d 开启Daemon模式 # --name hdh0.01 容器名称 ```  ##### 运行交互式的容器 ```shell docker run -i -t ubuntu:15.10 /bin/bash # -t:在新容器内指定一个伪终端或终端。 # -i:允许你对容器内的标准输入 (STDIN) 进行交互。 ```  ##### 启动容器（后台模式） ```shell  docker run -d ubuntu:15.10 /bin/sh -c "while true; do echo hello world; sleep 1; done"  # -d 开启Daemon模式 ```  #### 关闭容器  ```shell docker stop contain_id | name ```   #### docker查看日志  ```shell docker logs -f -t --since="2018-03-31" --tail=100 elastic_raman  # –since : 此参数指定了输出日志开始日期，即只输出指定日期之后的日志。  # -f : 表示查看实时日志  #　-t : 查看日志产生的日期  # -tail=200 : 查看最后的200条日志。  # sleepy_snyder 容器的名称，并不是镜像的名字 # # ps  #：执行docker ps命令可以看到docker容器列表，NAMES即为容器名，而不是image ``` #### 删除容器  ```shell docker container ls -a  docker container rm   XX  #   XX 为CONTAINER ID or NAMES ```  '},{title:"docker运行mariadb",path:"/posts/md/docker/mariadb.html",strippedContent:" #### 运行容器 ```shell docker run  --privileged --name mariadb   -d --restart=always -e TIMEZONE=Asis/Shanghai -e MYSQL_ROOT_PASSWORD=Admin123# -e SERVER_ID=1 -v /docker/mariadb/dbdata:/var/lib/mysql  -p 3306:3306  mariadb:10.4.5 --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci  #参数说明: #--privileged 赋予容器扩展权限(root) #设置--restart=always 参数的时候， 设置了此参数容器退出了会自动重启， 宿主机重启了容器也能自动重启            #-d后台运行  #TIMEZONE 设置时区 #MYSQL_ROOT_PASSWORD 设置root密码 #-v  /opt/data/mariadb/dbdata:/var/lib/mysql:/var/lib/mysql  将mariadb里面的目录（/var/lib/mysql）挂载到宿主机里面 #character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci 设置 utf-8字符集和排序规则 ```    ```sql --创建用户 CREATE USER sonar IDENTIFIED BY 'sonar'  --授权 GRANT ALL ON *.* TO 'sonar@localhost'  GRANT ALL PRIVILEGES ON *.* TO 'root'@'%'IDENTIFIED BY 'Admin123#' WITH GRANT OPTION; grant all privileges on *.* to sonar identified by 'sonar'; FLUSH PRIVILEGES;  -- mariadb 开启远程连接权限 grant all privileges on *.* to root@\"%\" identified by \"Admin123#\";   FLUSH PRIVILEGES;  --指定编码创建db CREATE DATABASE IF NOT EXISTS sonar DEFAULT CHARSET utf8mb4 COLLATE utf8mb4_general_ci;  --备份数据 mysqldump -uroot -p --all-database > bk.sql  ```"},{title:"docker compose",path:"/posts/md/docker/docker%20compose.html",strippedContent:" ### 安装  ```shell $ sudo curl -L https://github.com/docker/compose/releases/download/1.16.1/docker-compose-`uname -s`-`uname -m` \\  -o /usr/local/bin/docker-compose  ```  "},{title:"docker挂载目录",path:"/posts/md/docker/docker%E7%9B%AE%E5%BD%95.html",strippedContent:" #### 关于Docker目录挂载的总结  - 容器目录不可以为相对路径  - 宿主机目录如果不存在，则会自动生成  - 宿主机的目录如果为相对路径(实际上对路径指的是/var/lib/docker/volumes/，与宿主机的当前目录无关)  - 在容器内修改了目录的属主和属组，那么对应的挂载点会修改，容器销毁了，新建的挂载目录不会消失   挂载宿主机已存在目录后，在容器内对其进行操作，报“Permission denied”。  1> 关闭selinux。  2> 以特权方式启动容器  指定--privileged参数  "},{title:"docker相关问题",path:"/posts/md/docker/docker%20problem.html",strippedContent:" ##### \tdocker WARNING: IPv4 forwarding is disabled. 解决方法   ```shell #般情况下，我们的linux机器的ip forwarding选项都是关闭的。 但是如果我们的机器需要做网关，或路由器。那么这个就要打开了 echo net.ipv4.ip_forward=1 >> /usr/lib/sysctl.d/00-system.conf systemctl restart network && systemctl restart docker  #查看是否修改成功 sysctl net.ipv4.ip_forward ```  "},{title:"使用Dockerfile创建镜像",path:"/posts/md/docker/%E4%BD%BF%E7%94%A8Dockerfile%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F.html",strippedContent:' 在Dockerfile中用到的命令有  ##### FROM  ​    FROM指定一个基础镜像， 一般情况下一个可用的 Dockerfile一定是 FROM 为第一个指令。至于image则可以是任何合理存在的image镜像。 ​    FROM 一定是首个非注释指令 Dockerfile. ​    FROM 可以在一个 Dockerfile 中出现多次，以便于创建混合的images。 ​    如果没有指定 tag ，latest 将会被指定为要使用的基础镜像版本。  ##### MAINTAINER  ​    这里是用于指定镜像制作者的信息  ##### RUN  ​    RUN命令将在当前image中执行任意合法命令并提交执行结果。命令执行提交后，就会自动执行Dockerfile中的下一个指令。 ​    层级 RUN 指令和生成提交是符合Docker核心理念的做法。它允许像版本控制那样，在任意一个点，对image 镜像进行定制化构建。 ​    RUN 指令缓存不会在下个命令执行时自动失效。比如 RUN apt-get dist-upgrade -y 的缓存就可能被用于下一个指令. --no-cache 标志可以被用于强制取消缓存使用。  ##### ENV  ​    ENV指令可以用于为docker容器设置环境变量 ​    ENV设置的环境变量，可以使用 docker inspect命令来查看。同时还可以使用docker run --env `key`=`value`来修改环境变量。  ##### USER  ​    USER 用来切换运行属主身份的。Docker 默认是使用 root，但若不需要，建议切换使用者身分，毕竟 root 权限太大了，使用上有安全的风险。  ##### WORKDIR  ​    WORKDIR 用来切换工作目录的。Docker 默认的工作目录是/，只有 RUN 能执行 cd 命令切换目录，而且还只作用在当下下的 RUN，也就是说每一个 RUN 都是独立进行的。如果想让其他指令在指定的目录下执行，就得靠 WORKDIR。WORKDIR 动作的目录改变是持久的，不用每个指令前都使用一次 WORKDIR。  ##### COPY  ​    COPY 将文件从路径 `src` 复制添加到容器内部路径 `dest`。 ​    `src` 必须是想对于源文件夹的一个文件或目录，也可以是一个远程的url，`dest` 是目标容器中的绝对路径。 ​    所有的新文件和文件夹都会创建UID 和 GID 。事实上如果 `src` 是一个远程文件URL，那么目标文件的权限将会是600。  ##### ADD  ​    ADD 将文件从路径 `src` 复制添加到容器内部路径 `dest`。 ​    `src` 必须是想对于源文件夹的一个文件或目录，也可以是一个远程的url。`dest` 是目标容器中的绝对路径。 ​    所有的新文件和文件夹都会创建UID 和 GID。事实上如果 `src` 是一个远程文件URL，那么目标文件的权限将会是600。  ##### VOLUME  ​    创建一个可以从本地主机或其他容器挂载的挂载点，一般用来存放数据库和需要保持的数据等。  ##### EXPOSE  ​    EXPOSE 指令指定在docker允许时指定的端口进行转发。  ##### CMD  ​    Dockerfile.中只能有一个CMD指令。 如果你指定了多个，那么最后个CMD指令是生效的。 ​    CMD指令的主要作用是提供默认的执行容器。这些默认值可以包括可执行文件，也可以省略可执行文件。 ​    当你使用shell或exec格式时，  CMD 会自动执行这个命令。  ##### ONBUILD  ​    ONBUILD 的作用就是让指令延迟執行，延迟到下一个使用 FROM 的 Dockerfile 在建立 image 时执行，只限延迟一次。 ​    ONBUILD 的使用情景是在建立镜像时取得最新的源码 (搭配 RUN) 与限定系统框架。  ##### ARG  ​    ARG是Docker1.9 版本才新加入的指令。 ​    ARG 定义的变量只在建立 image 时有效，建立完成后变量就失效消失  ##### LABEL  ​    定义一个 image 标签 Owner，并赋值，其值为变量 Name 的值。(LABEL Owner=$Name )  ##### ENTRYPOINT  ​    是指定 Docker image 运行成 instance (也就是 Docker container) 时，要执行的命令或者文件。 ​        我自己的Dockerfile文件内容如下：  ```shell FROM docker.io/centos MAINTAINER The CentOS Test Images - test RUN mkdir -p /usr/app RUN ls RUN pwd COPY /jdk /usr/app/jdk/ ADD tomcat/ /usr/app/tomcat/ ADD hadoop/ /usr/app/hadoop/ ENV JAVA_HOME /usr/app/jdk ENV PATH $JAVA_HOME/bin:$PATH #ADD /soft/jdk / #ADD /soft/tomcat / #ADD /soft/hadoop / # Volumes for systemd # VOLUME ["/run", "/tmp"] # Environment for systemd # ENV container=docker # For systemd usage this changes to /usr/sbin/init # Keeping it as /bin/bash for compatibility with previous #CMD ["/bin/bash"] ```  '},{title:"mybatis获取主键",path:"/posts/md/part/mybatis.html",strippedContent:' ### Mybatis 在 insert 之后想获取自增的主键 id，但却总是返回1  想要获取自增主键id，需要通过xx.getId()方法获取，因为在mybatis中指定自增主键id封装到了对象的属性中，所以我们需要在对象中来获取  ```xml <insert id="add" useGeneratedKeys="true" keyColumn="id" keyProperty="id" parameterType="user">     INSERT INTO `user` (`name`,sex,register_ts) VALUES (#{name},#{sex},#{registerTs})     <selectKey resultType="int" keyProperty="id" order="AFTER">         SELECT LAST_INSERT_ID()     </selectKey> </insert> ```  ### 总结：  1.  想要获取自增主键id，应该通过对象的getId()方法，而并不是insert的返回值，insert的返回值表示的是影响行数  2.  在mapper.xml中：useGeneratedKeys="true"、keyProperty="id"，这两个属性的作用：       - 共同决定了sql执行后，会将主键封装到id属性上；          - 自增主键封装到了对象的id属性上了，那么想要获取，直接调用对象的getId()方法就可以了'},{title:"响应式编程",path:"/posts/md/Reactive%20Programming.html",strippedContent:" #### 响应式编程核心特征   - 变化传递(propagation of change) - 基于数据流(data stream) - 声明式(declarative)    #### 响应式流  - 异步非阻塞 - 流量控制  (ps Java Stream是一种同步API)      阻塞造成的性能损失，我们通常有两种思路来解决  1. 并行化：使用更多的线程和硬件资源； 2. 异步化：基于现有的资源来提高执行效率。"},{title:"consul介绍",path:"/posts/md/part/microServices/consul.html",strippedContent:" consul是分布式的、高可用、横向扩展的（CP）。consul提供的一些关键特性：  - service discovery：consul通过DNS或者HTTP接口使服务注册和服务发现变的很容易，一些外部服务，例如saas提供的也可以一样注册。 - health checking：健康检测使consul可以快速的告警在集群中的操作。和服务发现的集成，可以防止服务转发到故障的服务上面。 - key/value storage：一个用来存储动态配置的系统。提供简单的HTTP接口，可以在任何地方操作。 - multi-datacenter：无需复杂的配置，即可支持任意数量的区域。  "},{title:"KVM架构和Xen架构",path:"/posts/md/other/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%9E%B6%E6%9E%84.html",strippedContent:" 简述KVM架构和Xen架构 暑假最后一篇更新，因为，，，明天我就回学校了。  以下均为个人理解，如果有不对的地方还望各位dalao不吝赐教。  虚拟化 虚拟化是通过Hypervisor程序实现的，Hypervisor的作用是将硬件虚拟化提供给多个操作系统使用，是虚拟化技术的核心。 虚拟化分为两种：`1型虚拟化`和`2型虚拟化`。  1型虚拟化是将Hypervisor直接安装在物理机上，然后虚拟机直接运行在Hypervisor上，Xen就是属于1型虚拟化。 2型虚拟化是先在硬件上安装操作系统，然后将Hypervisor作为系统的一个程序运行在系统上从而实现对虚拟机的管理，KVM就是属于2型虚拟化。  #### KVM架构  先来看一下KVM，KVM是基于Linux内核实现的，KVM的内核模块叫做kvm.ko，实现对Linux的CPU和内存虚拟化，是Linux的一个进程，负责VCPU和内存的分配,而其他设备的虚拟就交给了qemu。 qemu运行在用户空间，KVM运行在内核，两者通过/dev/kvm进行交互。 KVM仅支持全局虚拟化。  #### Xen架构  再来看一下Xen，Xen支持全虚拟化和半虚拟化，（全虚拟化就是运行在虚拟环境的虚拟机无法感知到自己是运行在虚拟环境之上，只会觉得自己是运行在硬件之上，半虚拟化是运行在虚拟环境的虚拟机可以感知到自己不是直接运行在硬件环境之上）这一点不同于KVM的仅支持全局虚拟化。Xen是直接运行在硬件上的，也就是上面提到的1型虚拟化，直接对硬件进行虚拟化，然后在硬件之上直接跑虚拟机，在Xen架构中的虚拟机分为两种：Domain0和DoaminU.Domain0又叫做特权虚拟机，具有直接访问硬件和管理其他操作系统的权限，而DoaminU就是普通的虚拟机，DoaminU不能直接访问硬件，所有的操作都是通过驱动发送到特权虚拟机Domain0，由Domain0去和硬件交互再返回给普通用户，所以，Xen架构的虚拟化需要先运行Domain0。 Xen架构也是对CPU和内存进行虚拟化,提供给虚拟机用，其余硬件访问是通过特权虚拟机直接与硬件进行交互再返回的。 默认Domain0VCPU和内存的大小是这样计算的：  Domain0的VCPU = 物理设备线程数 % 10然后向上取最小的一个偶数，就是Domain0的VCPU数。 Domain0的内存：如果物理设备的内存小于96G，那么就默认为8G,如果物理机的内存大于96G，那么Domain0的内存 = 物理机内存 *0.05 + 8G。"},{title:"docker运行redis",path:"/posts/md/docker/redis.html",strippedContent:" #### 运行容器  ```shell docker run  --privileged  --name redis -v /docker/redis/data:/data  -p  6379:6379 -d redis:5.0.5  redis-server --appendonly yes ```      ```powershell  #客户端连 redis redis-cli.exe -h 192.168.85.135 -p 6379 ```  "},{title:"面试",path:"/posts/md/part/interview/interview.html",strippedContent:" ### 如何提高求职时的谈判能力？  1. 记住你不是在展示编程技巧或者漂亮的脸蛋，而是在推销某种商业需求（增加收入或降低成本）的解决方案。 2. 面试时，要有自信，要平等的对话。你的对手可能也在做同样的事情。你要的是一个互利的录用合同，不要每次对方提出要求，你都说 Yes。  3. 雇主可能会问”你的上一份工资是多少”，他们其实在说”给我一个理由，压低你的报酬”。你要想好如何适当地回答这个问题。  4. 要讨价还价。这里不仅仅指钱，还指其它你关心的方面。如果你无法要求更高的薪水，那就试着要求更多的假期。  5. 在对方决定录用你以后，才开始讨论薪水。因为那时，他们已经在你身上，投入了大量的时间和金钱。这个时候他们说“不行，我们不能成交”会浪费很大的成本，他们会觉得一些小问题已经不值得再纠缠了，比如每年的工资增加几千元。  6. 多读书吧。很多人写过谈判方面的书。我喜欢《Getting To Yes | 谈判力》这本书。有一点令人不解的是，就整个职业生涯而言，谈判技巧值得每年花费数千美元，但工程师们却认为针对这学习方面很疯狂，他们宁愿去学习感兴趣技术的细枝末节。      spring的事务传播机制 springmvc参数绑定原理 mybatis的分页原理 limit  "},{title:"测试相关",path:"/posts/md/%E6%B5%8B%E8%AF%95.html",strippedContent:" 把数据把某种逻辑来分类: 把一张表拆成多张有一样的字段但是不同种类的表  把数据按字段分，也就是竖着分表: 把一些不经常改的数据放在一个表里，经常改的数据放在另外多个表里。把一张表变成1对1的关系  平均分表: 通过主键ID的范围来分表。    #### 测试分类  冒烟测试; \t冒烟测试就是先保证系统能跑的起来，不至于让测试工作做到一半突然出现错误导致业务中断。目的就是先通过最基本的测试 \t 猴子测试: \t它针对的不是功能点，而是业务流程,就是说，你把自己看成白痴，随便乱点，没有任何主观想法参与进来，让一些想不到的操作呈现出错误来 \t \t 数据库来说吧， 数据做了分区， 一致性怎么保证啊？   选择分布式事务非常麻烦， 有时候不得不选择最终一致性来妥协  迅速定位问题:  一是查看错误日志，推断错误的可能"},{title:"netty介绍",path:"/posts/md/%E9%AB%98%E5%8F%AF%E7%94%A8/Netty.html",strippedContent:" netty是由JBOSS提供的一个java开源框架。 netty提供异步的、事件驱动的网络应用程序框架和工具，用以快速开发高性能、高可靠性的网络服务器和客户端程序。  netty：异步非阻塞开源框架 bio：同步阻塞 nio：同步非阻塞 bio：异步非阻塞  一个IO操作其实分成了两个步骤：发起IO请求和实际的IO操作。  同步IO和异步IO的区别就在于第二个步骤是否阻塞，如果实际的IO读写阻塞请求进程，那么就是同步IO。  阻塞IO和非阻塞IO的区别在于第一步，发起IO请求是否会被阻塞，如果阻塞直到完成那么就是传统的阻塞IO，如果不阻塞，那么就是非阻塞IO。     - 同步阻塞：你到饭馆点餐，然后在那等着，还要一边喊：好了没啊！   - 同步非阻塞：在饭馆点完餐，就去遛狗了。不过溜一会儿，就回饭馆喊一声：好了没啊！   - 异步阻塞：遛狗的时候，接到饭馆电话，说饭做好了，让您亲自去拿。   - 异步非阻塞：饭馆打电话说，我们知道您的位置，一会给你送过来，安心遛狗就可以了。 "},{title:"代理模式与装饰模式",path:"/posts/md/pattern.html",strippedContent:" 代理模式主要是控制对某个特定对象访问，而装饰模式主要是为了给对象添加行为  代理模式和装饰模式非常类似，甚至代码都类似。二者最主要的区别是：代理模式中，代理类对被代理的对象有控制权，决定其执行或者不执行。而装饰模式中，装饰类对代理对象没有控制权，只能为其增加一层装饰，以加强被装饰对象的功能，仅此而已。"},{title:"公钥与私钥",path:"/posts/md/tool/encrypt.html",strippedContent:" 公钥与私钥使用，在大部分情况下    - 我们使用公钥加密、私钥解密，  - `签名`却是使用私钥加密，公钥解密        "},{title:"分布式",path:"/posts/md/part/Distributed/Distributed.html",strippedContent:" `通信渠道的不可靠`（超时等）是造成构建大规模分布式系统非常复杂并且困难的重要原因。  "},{title:"docker运行sonarqube",path:"/posts/md/docker/sonarqube.html",strippedContent:" ```shell docker run -d --name sonarqube \\     -e sonar.jdbc.username=sonar \\     -e sonar.jdbc.password=sonar \\     -e sonar.jdbc.url=jdbc:mariadb://localhost:3306/sonar \\     -p 9000:9000 \\     -v /path/to/conf:/opt/sonarqube/conf \\     -v /path/to/data:/opt/sonarqube/data \\     -v /path/to/logs:/opt/sonarqube/logs \\     -v /path/to/extensions:/opt/sonarqube/extensions \\     sonarqube:6.7.7-community; ```  "},{title:"gc",path:"/posts/md/langu/jdk/gc.html",strippedContent:" CMS  重新标记（Remark） 的作用在于： 之前在并发标记时，因为是 GC 和用户程序是并发执行的，可能导致一部分已经标记为 从 GC Roots 不可达 的对象，因为用户程序的（并发）运行，又可达 了，Remark 的作用就是将这部分对象又标记为 可达对象。  至于 `“浮动垃圾”`，因为 CMS 在 并发标记 时是并发的，GC 线程和用户线程并发执行，这个过程当然可能会因为线程的交替执行而导致新产生的垃圾（即浮动垃圾）没有被标记到；而 重新标记 的作用只是修改之前 并发标记 所获得的不可达对象，所以是没有办法处理 “浮动垃圾” 的。  remark过程标记活着的对象，从GCRoot的可达性判断对象活着，但无法标记“死亡”的对象。 如果在初始标记阶段被标记为活着，并发运行过程中“死亡”，remark过程无法纠正，因此变为浮动垃圾，需等待下次gc的到来。  #### 触发MinorGC(Young GC)  ​    虚拟机在进行minorGC之前会判断老年代最大的可用连续空间是否大于新生代的所有对象总空间  - 如果大于的话，直接执行minorGC  - 如果小于，判断是否开启HandlerPromotionFailure，没有开启直接FullGC  - 如果开启了HanlerPromotionFailure, JVM会判断老年代的最大连续内存空间是否大于历次晋升的大小，如果小于直接执行FullGC  - 如果大于的话，执行minorGC    #### 触发FullGC  ###### 老年代空间不足  ​     如果创建一个大对象，Eden区域当中放不下这个大对象，会直接保存在老年代当中，如果老年代空间也不足，就会触发Full GC。为了避免这种情况，最好就是不要创建太大的对象。  ###### 持久代空间不足  ​    如果有持久代空间的话，系统当中需要加载的类，调用的方法很多，同时持久代当中没有足够的空间，就出触发一次Full GC  ###### YGC出现promotion failure  ​    promotion failure发生在Young GC, 如果Survivor区当中存活对象的年龄达到了设定值，会就将Survivor区当中的对象拷贝到老年代，如果老年代的空间不足，就会发生promotion failure， 接下去就会发生Full GC.  ###### 统计YGC发生时晋升到老年代的平均总大小大于老年代的空闲空间  ​      在发生YGC是会判断，是否安全，这里的安全指的是，当前老年代空间可以容纳YGC晋升的对象的平均大小，如果不安全，就不会执行YGC,转而执行Full GC。  ###### 显示调用System.gc"},{title:"nginx介绍",path:"/posts/md/%E9%AB%98%E5%8F%AF%E7%94%A8/nginx.html",strippedContent:' #### 配置出错  ```shell #重启nginx nginx -s reload nginx: [emerg] unexpected "}" in /etc/nginx/nginx.conf:79  #A: 行尾没带分号   #检查修改的nginx.conf配置是否正确 nginx -t ```    #### upstream与ip_hash  ```nginx # upstream 负载均衡  upstream firstdemo {   # ip_hash  粘性IP  相当一段时间，只会跟第一访问sever   ip_hash;      #  同一个url（也就是同一个资源请求）会到达同一台机器,配合缓存命中   hash $request_uri;     server 39.106.145.33;   server 47.93.6.93; } ```  Ip_hash机制缺陷:  - ip_hash要求nginx一定是最前端的服务器,否则nginx得不到正确ip,就不能根据ip作hash.\tEg: 使用的是squid为最前端.那么nginx取ip时只能得到squid的服务器ip地址,用这个地址来作分流肯定是错乱的 - 假如nginx后端还有其它负载均衡,将请求又通过另外的方式分流了,那么某个客户端的请求肯定不能定位到同一台session应用服务器上,这么算起来,nginx后端只能直接指向应用服务器,或者再搭一人squid,然后指向应用服务器. 最好 的办法是用location作一次分流,将需要session的部分请求通过ip_hash分流,剩下的走其它后端去.   #### 常规示例  ```nginx server {     listen 80;     server_name  www.mqiy.xyz ;     auth_basic off;     location / {         proxy_pass    http://10.10.10.10:20186;         proxy_set_header Host $host;         proxy_redirect off;         proxy_set_header X-Real-IP $remote_addr;         proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;         proxy_connect_timeout 60;         proxy_read_timeout 600;         proxy_send_timeout 600;     } } ```  '}]}}]);