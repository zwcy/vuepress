(window.webpackJsonp=window.webpackJsonp||[]).push([[112],{340:function(a,r,t){"use strict";t.r(r);var v=t(17),_=Object(v.a)({},(function(){var a=this,r=a.$createElement,t=a._self._c||r;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h3",{attrs:{id:"rpc"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#rpc","aria-hidden":"true"}},[a._v("#")]),a._v(" RPC")]),a._v(" "),t("p",[a._v("它是Remote Procedure Call(远程过程调用)的简称。一般基于RPC协议所设计的接口，是基于网络采用客户端/服务端的模式完成调用接口的")]),a._v(" "),t("h4",{attrs:{id:"优点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#优点","aria-hidden":"true"}},[a._v("#")]),a._v(" 优点")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("简单并且易于理解（面向开发者）")])]),a._v(" "),t("li",[t("p",[a._v("轻量级的数据载体")])]),a._v(" "),t("li",[t("p",[a._v("高性能")])])]),a._v(" "),t("h4",{attrs:{id:"缺点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#缺点","aria-hidden":"true"}},[a._v("#")]),a._v(" 缺点")]),a._v(" "),t("ul",[t("li",[a._v("对于系统本身耦合性高")]),a._v(" "),t("li",[a._v("因为RPC本身很简单、轻量，因此很容易造成 function explosion")])]),a._v(" "),t("p",[a._v("关于RPC的优点其实很好理解，就是因为它性能高同时又很简单，但是我认为这是对于接口提供者来讲的（因为它的高耦合性）。")]),a._v(" "),t("p",[a._v("但是如果从接口调用者的角度来看，高耦合性就变成了缺点，因为高耦合意味着调用者必须要足够了解系统本身的实现才能够完成调用，比如：")]),a._v(" "),t("ul",[t("li",[a._v("调用者需要知道所调用接口的函数名、参数格式、参数顺序、参数名称等等")]),a._v(" "),t("li",[a._v("如果接口提供者(server)要对接口做出一些改变，很容易对接口调用者(client)造成breaking change（违背开闭原则)")]),a._v(" "),t("li",[a._v("一般RPC所暴露接口仅仅会暴露函数的名称和参数等信息，对于函数之间的调用关系无法提供，这意味着调用者必须足够了解系统，从能够知道如何正确的调用这些接口，但是对于接口调用者往往不需要了解过多系统内部实现细节")])]),a._v(" "),t("hr"),a._v(" "),t("h3",{attrs:{id:"rest"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#rest","aria-hidden":"true"}},[a._v("#")]),a._v(" REST")]),a._v(" "),t("p",[a._v("当前REST风格的API架构方式已经成了主流解决方案了，相比较RPC，它的主要不同之处在于，它是对于资源(Resource)的模型化而非步骤(Procedure)。")]),a._v(" "),t("h4",{attrs:{id:"优点-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#优点-2","aria-hidden":"true"}},[a._v("#")]),a._v(" 优点")]),a._v(" "),t("ul",[t("li",[a._v("对于系统本身耦合性低，调用者不再需要了解接口内部处理和实现细节")]),a._v(" "),t("li",[a._v("重复使用了一些 http 协议中的已定义好的部分状态动词，增强语义表现力")]),a._v(" "),t("li",[a._v("API可以随着时间而不断演进")])]),a._v(" "),t("h4",{attrs:{id:"缺点-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#缺点-2","aria-hidden":"true"}},[a._v("#")]),a._v(" 缺点")]),a._v(" "),t("ul",[t("li",[a._v("缺少约束，缺少简单、统一的规范")]),a._v(" "),t("li",[a._v("有时候 payload 会变的冗余(overload)，有时候调用api会比较繁琐(chattiness)")]),a._v(" "),t("li",[a._v("有时候需要发送多条请求已获取数据，在网络带宽较低的场景，往往会造成不好的影响")])]),a._v(" "),t("p",[a._v("REST的优点基本解决了RPC中存在的问题，就是解耦，从而使得前后端分离成为可能。接口提供者在修改接口时，不容易造成breaking-change，接口调用者在调用接口时，往往面向数据模型编程，而省去了了解接口本身的时间成本。")]),a._v(" "),t("p",[a._v("但是，我认为REST当前最大的问题在于虽然它利用"),t("code",[a._v("http")]),a._v("的动词约束了接口的暴露方式，同时增强了语义，但是却没有约束接口如何返回数据的最佳实践")]),a._v(" "),t("hr"),a._v(" "),t("h3",{attrs:{id:"graphql"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#graphql","aria-hidden":"true"}},[a._v("#")]),a._v(" GraphQL")]),a._v(" "),t("p",[a._v("GraphQL是近来比较热门的一个技术话题，相比REST和RPC，它汲取了两者的优点，即不面向资源，也不面向过程，而是面向数据查询(ask for exactly what you want)。同时GraphQL本身需要使用强类型的Schema来对数据模型进行定义，因此相比REST它的约束性更强。")]),a._v(" "),t("h4",{attrs:{id:"优点-3"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#优点-3","aria-hidden":"true"}},[a._v("#")]),a._v(" 优点")]),a._v(" "),t("ul",[t("li",[a._v("网络开销低，可以在单一请求中获取REST中使用多条请求获取的资源")]),a._v(" "),t("li",[a._v("强类型Schema（约束意味着可以根据规范形成文档、IDE、错误提示等生态工具）")]),a._v(" "),t("li",[a._v("特别适合图状数据结构的业务场景（比如好友、流程、组织架构等系统）")])]),a._v(" "),t("h4",{attrs:{id:"缺点-3"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#缺点-3","aria-hidden":"true"}},[a._v("#")]),a._v(" 缺点")]),a._v(" "),t("ul",[t("li",[a._v("本身的语法相比较REST和RPC均复杂一些")]),a._v(" "),t("li",[a._v("实现方面需要配套 Caching 以解决性能瓶颈")]),a._v(" "),t("li",[a._v("对于 API 的版本控制当前没有完善解决方案（社区的建议是不要使API版本化）")]),a._v(" "),t("li",[a._v("仍然是新鲜事物，很多技术细节仍然处于待验证状态\n首先值得肯定的是，在某些程度上确实解决了REST的缺点所带来的问题,GraphQL所带来的好处，大部分是对于接口调用者而言的，但是实现这部分的工作却需要接口提供者来完成。")])])])}),[],!1,null,null,null);r.default=_.exports}}]);