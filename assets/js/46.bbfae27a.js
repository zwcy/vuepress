(window.webpackJsonp=window.webpackJsonp||[]).push([[46],{422:function(r,a,t){"use strict";t.r(a);var e=t(17),i=Object(e.a)({},(function(){var r=this,a=r.$createElement,t=r._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[t("p",[r._v("CMS")]),r._v(" "),t("p",[r._v("重新标记（Remark） 的作用在于：\n之前在并发标记时，因为是 GC 和用户程序是并发执行的，可能导致一部分已经标记为 从 GC Roots 不可达 的对象，因为用户程序的（并发）运行，又可达 了，Remark 的作用就是将这部分对象又标记为 可达对象。")]),r._v(" "),t("p",[r._v("至于 "),t("code",[r._v("“浮动垃圾”")]),r._v("，因为 CMS 在 并发标记 时是并发的，GC 线程和用户线程并发执行，这个过程当然可能会因为线程的交替执行而导致新产生的垃圾（即浮动垃圾）没有被标记到；而 重新标记 的作用只是修改之前 并发标记 所获得的不可达对象，所以是没有办法处理 “浮动垃圾” 的。")]),r._v(" "),t("p",[r._v("remark过程标记活着的对象，从GCRoot的可达性判断对象活着，但无法标记“死亡”的对象。\n如果在初始标记阶段被标记为活着，并发运行过程中“死亡”，remark过程无法纠正，因此变为浮动垃圾，需等待下次gc的到来。")]),r._v(" "),t("h4",{attrs:{id:"触发minorgc-young-gc"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#触发minorgc-young-gc","aria-hidden":"true"}},[r._v("#")]),r._v(" 触发MinorGC(Young GC)")]),r._v(" "),t("p",[r._v("​    虚拟机在进行minorGC之前会判断老年代最大的可用连续空间是否大于新生代的所有对象总空间")]),r._v(" "),t("ul",[t("li",[t("p",[r._v("如果大于的话，直接执行minorGC")])]),r._v(" "),t("li",[t("p",[r._v("如果小于，判断是否开启HandlerPromotionFailure，没有开启直接FullGC")])]),r._v(" "),t("li",[t("p",[r._v("如果开启了HanlerPromotionFailure, JVM会判断老年代的最大连续内存空间是否大于历次晋升的大小，如果小于直接执行FullGC")])]),r._v(" "),t("li",[t("p",[r._v("如果大于的话，执行minorGC")])])]),r._v(" "),t("h4",{attrs:{id:"触发fullgc"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#触发fullgc","aria-hidden":"true"}},[r._v("#")]),r._v(" 触发FullGC")]),r._v(" "),t("h6",{attrs:{id:"老年代空间不足"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#老年代空间不足","aria-hidden":"true"}},[r._v("#")]),r._v(" 老年代空间不足")]),r._v(" "),t("p",[r._v("​     如果创建一个大对象，Eden区域当中放不下这个大对象，会直接保存在老年代当中，如果老年代空间也不足，就会触发Full GC。为了避免这种情况，最好就是不要创建太大的对象。")]),r._v(" "),t("h6",{attrs:{id:"持久代空间不足"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#持久代空间不足","aria-hidden":"true"}},[r._v("#")]),r._v(" 持久代空间不足")]),r._v(" "),t("p",[r._v("​    如果有持久代空间的话，系统当中需要加载的类，调用的方法很多，同时持久代当中没有足够的空间，就出触发一次Full GC")]),r._v(" "),t("h6",{attrs:{id:"ygc出现promotion-failure"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ygc出现promotion-failure","aria-hidden":"true"}},[r._v("#")]),r._v(" YGC出现promotion failure")]),r._v(" "),t("p",[r._v("​    promotion failure发生在Young GC, 如果Survivor区当中存活对象的年龄达到了设定值，会就将Survivor区当中的对象拷贝到老年代，如果老年代的空间不足，就会发生promotion failure， 接下去就会发生Full GC.")]),r._v(" "),t("h6",{attrs:{id:"统计ygc发生时晋升到老年代的平均总大小大于老年代的空闲空间"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#统计ygc发生时晋升到老年代的平均总大小大于老年代的空闲空间","aria-hidden":"true"}},[r._v("#")]),r._v(" 统计YGC发生时晋升到老年代的平均总大小大于老年代的空闲空间")]),r._v(" "),t("p",[r._v("​      在发生YGC是会判断，是否安全，这里的安全指的是，当前老年代空间可以容纳YGC晋升的对象的平均大小，如果不安全，就不会执行YGC,转而执行Full GC。")]),r._v(" "),t("h6",{attrs:{id:"显示调用system-gc"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#显示调用system-gc","aria-hidden":"true"}},[r._v("#")]),r._v(" 显示调用System.gc")])])}),[],!1,null,null,null);a.default=i.exports}}]);