(window.webpackJsonp=window.webpackJsonp||[]).push([[84],{379:function(n,e,a){"use strict";a.r(e);var i=a(17),o=Object(i.a)({},(function(){var n=this,e=n.$createElement,a=n._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("p",[n._v("简述KVM架构和Xen架构\n暑假最后一篇更新，因为，，，明天我就回学校了。")]),n._v(" "),a("p",[n._v("以下均为个人理解，如果有不对的地方还望各位dalao不吝赐教。")]),n._v(" "),a("p",[n._v("虚拟化\n虚拟化是通过Hypervisor程序实现的，Hypervisor的作用是将硬件虚拟化提供给多个操作系统使用，是虚拟化技术的核心。\n虚拟化分为两种："),a("code",[n._v("1型虚拟化")]),n._v("和"),a("code",[n._v("2型虚拟化")]),n._v("。")]),n._v(" "),a("p",[n._v("1型虚拟化是将Hypervisor直接安装在物理机上，然后虚拟机直接运行在Hypervisor上，Xen就是属于1型虚拟化。\n2型虚拟化是先在硬件上安装操作系统，然后将Hypervisor作为系统的一个程序运行在系统上从而实现对虚拟机的管理，KVM就是属于2型虚拟化。")]),n._v(" "),a("h4",{attrs:{id:"kvm架构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#kvm架构","aria-hidden":"true"}},[n._v("#")]),n._v(" KVM架构")]),n._v(" "),a("p",[n._v("先来看一下KVM，KVM是基于Linux内核实现的，KVM的内核模块叫做kvm.ko，实现对Linux的CPU和内存虚拟化，是Linux的一个进程，负责VCPU和内存的分配,而其他设备的虚拟就交给了qemu。\nqemu运行在用户空间，KVM运行在内核，两者通过/dev/kvm进行交互。\nKVM仅支持全局虚拟化。")]),n._v(" "),a("h4",{attrs:{id:"xen架构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#xen架构","aria-hidden":"true"}},[n._v("#")]),n._v(" Xen架构")]),n._v(" "),a("p",[n._v("再来看一下Xen，Xen支持全虚拟化和半虚拟化，（全虚拟化就是运行在虚拟环境的虚拟机无法感知到自己是运行在虚拟环境之上，只会觉得自己是运行在硬件之上，半虚拟化是运行在虚拟环境的虚拟机可以感知到自己不是直接运行在硬件环境之上）这一点不同于KVM的仅支持全局虚拟化。Xen是直接运行在硬件上的，也就是上面提到的1型虚拟化，直接对硬件进行虚拟化，然后在硬件之上直接跑虚拟机，在Xen架构中的虚拟机分为两种：Domain0和DoaminU.Domain0又叫做特权虚拟机，具有直接访问硬件和管理其他操作系统的权限，而DoaminU就是普通的虚拟机，DoaminU不能直接访问硬件，所有的操作都是通过驱动发送到特权虚拟机Domain0，由Domain0去和硬件交互再返回给普通用户，所以，Xen架构的虚拟化需要先运行Domain0。\nXen架构也是对CPU和内存进行虚拟化,提供给虚拟机用，其余硬件访问是通过特权虚拟机直接与硬件进行交互再返回的。\n默认Domain0VCPU和内存的大小是这样计算的：")]),n._v(" "),a("p",[n._v("Domain0的VCPU = 物理设备线程数 % 10然后向上取最小的一个偶数，就是Domain0的VCPU数。\nDomain0的内存：如果物理设备的内存小于96G，那么就默认为8G,如果物理机的内存大于96G，那么Domain0的内存 = 物理机内存 *0.05 + 8G。")])])}),[],!1,null,null,null);e.default=o.exports}}]);