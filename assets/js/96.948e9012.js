(window.webpackJsonp=window.webpackJsonp||[]).push([[96],{364:function(n,o,t){"use strict";t.r(o);var e=t(17),v=Object(e.a)({},(function(){var n=this,o=n.$createElement,t=n._self._c||o;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("p",[n._v("socket多线程                     ok\nnetty底层nio，aio                ok\n高并发                           ok\n分布式事务                       ok\n事务控制多库多表操作             ok\nspring cloud\nsoa                              ignore\njvm调优                          ok\n类加载机制                       ok\ngc机制                           ok\n支付流程和注意点"),t("br"),n._v("\nspring的加载机制                 ok\ntomcat加载机制                   ignore\n做过的项目                       important")]),n._v(" "),t("p",[n._v("线程调度；多线程相关：多线程并发用到那哪些？线程数据共享；synchronize 用法，原理 ？死锁的原因，现场写了一下；（重点）")]),n._v(" "),t("p",[n._v("首先要了解高并发的的瓶颈在哪里？")]),n._v(" "),t("p",[n._v("1、可能是服务器网络带宽不够\n增加网络带宽，添加CDN")]),n._v(" "),t("p",[n._v("2.可能web线程连接数不够\n负载均衡，前置代理服务器nginx，静态资源分离到另外一个服务器")]),n._v(" "),t("p",[n._v("3.可能数据库连接查询上不去。\n优化数据库查询语句，explain之后，找出耗时多的点，添加索引。\n数据库查询优化，读写分离，分表等等")]),n._v(" "),t("p",[n._v("4.使用缓存，比较固定长时间少更新的solr，短期的也可以用redis，memcache")]),n._v(" "),t("p",[n._v("最后复制一些在高并发下面需要常常需要处理的内容:")]),n._v(" "),t("p",[n._v("统计的功能尽量做缓存，或按每天一统计或定时统计相关报表，避免需要时进行统计的功能。")]),n._v(" "),t("p",[n._v("能使用静态页面的地方尽量使用，减少容器的解析（尽量将动态内容生成静态html来显示）。")]),n._v(" "),t("p",[n._v("解决以上问题后，使用服务器集群来解决单台的瓶颈问题。")])])}),[],!1,null,null,null);o.default=v.exports}}]);