(window.webpackJsonp=window.webpackJsonp||[]).push([[54],{423:function(a,r,t){"use strict";t.r(r);var e=t(17),o=Object(e.a)({},(function(){var a=this,r=a.$createElement,t=a._self._c||r;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h3",{attrs:{id:"内存屏障（memory-barrier）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#内存屏障（memory-barrier）","aria-hidden":"true"}},[a._v("#")]),a._v(" 内存屏障（Memory barrier）")]),a._v(" "),t("h4",{attrs:{id:"为什么会有内存屏障"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么会有内存屏障","aria-hidden":"true"}},[a._v("#")]),a._v(" 为什么会有内存屏障")]),a._v(" "),t("ul",[t("li",[a._v("每个CPU都会有自己的缓存（有的甚至L1,L2,L3），缓存的目的就是为了提高性能，避免每次都要向内存取。但是这样的弊端也很明显：不能实时的和内存发生信息交换，分在不同CPU执行的不同线程对同一个变量的缓存值不同。")]),a._v(" "),t("li",[a._v("用volatile关键字修饰变量可以解决上述问题，那么volatile是如何做到这一点的呢？那就是内存屏障，内存屏障是硬件层的概念，不同的硬件平台实现内存屏障的手段并不是一样，java通过屏蔽这些差异，统一由jvm来生成内存屏障的指令。")])]),a._v(" "),t("h4",{attrs:{id:"内存屏障是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#内存屏障是什么","aria-hidden":"true"}},[a._v("#")]),a._v(" 内存屏障是什么")]),a._v(" "),t("p",[a._v("硬件层的内存屏障分为两种："),t("code",[a._v("Load Barrier")]),a._v(" 和 "),t("code",[a._v("Store Barrier")]),a._v("即读屏障和写屏障。\n内存屏障有两个作用："),t("br"),a._v("\n阻止屏障两侧的指令重排序；"),t("br"),a._v("\n强制把写缓冲区/高速缓存中的脏数据等写回主内存，让缓存中相应的数据失效。")]),a._v(" "),t("ul",[t("li",[a._v("对于Load Barrier来说，在指令前插入Load Barrier，可以让高速缓存中的数据失效，强制从新从主内存加载数据；")]),a._v(" "),t("li",[a._v("对于Store Barrier来说，在指令后插入Store Barrier，能让写入缓存中的最新数据更新写入主内存，让其他线程可见。")])]),a._v(" "),t("h4",{attrs:{id:"java内存屏障"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java内存屏障","aria-hidden":"true"}},[a._v("#")]),a._v(" java内存屏障")]),a._v(" "),t("p",[a._v("java的内存屏障通常所谓的四种即LoadLoad,StoreStore,LoadStore,StoreLoad实际上也是上述两种的组合，完成一系列的屏障和数据同步功能。")]),a._v(" "),t("ul",[t("li",[a._v("LoadLoad屏障：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。")]),a._v(" "),t("li",[a._v("StoreStore屏障：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。")]),a._v(" "),t("li",[a._v("LoadStore屏障：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。")]),a._v(" "),t("li",[a._v("StoreLoad屏障：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能")])]),a._v(" "),t("h4",{attrs:{id:"volatile语义中的内存屏障"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#volatile语义中的内存屏障","aria-hidden":"true"}},[a._v("#")]),a._v(" volatile语义中的内存屏障")]),a._v(" "),t("p",[a._v("volatile的内存屏障策略非常严格保守，非常悲观且毫无安全感的心态：\n在每个volatile写操作前插入StoreStore屏障，在写操作后插入StoreLoad屏障；\n在每个volatile读操作前插入LoadLoad屏障，在读操作后插入LoadStore屏障；")]),a._v(" "),t("blockquote",[t("p",[a._v("由于内存屏障的作用，避免了volatile变量和其它指令重排序、线程之间实现了通信，使得volatile表现出了锁的特性。")])]),a._v(" "),t("h4",{attrs:{id:"final语义中的内存屏障"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#final语义中的内存屏障","aria-hidden":"true"}},[a._v("#")]),a._v(" final语义中的内存屏障")]),a._v(" "),t("p",[a._v("对于final域，编译器和CPU会遵循两个排序规则：")]),a._v(" "),t("blockquote",[t("p",[a._v("新建对象过程中，构造体中对final域的初始化写入和这个对象赋值给其他引用变量，这两个操作不能重排序；（废话嘛）")])]),a._v(" "),t("blockquote",[t("p",[a._v("初次读包含final域的对象引用和读取这个final域，这两个操作不能重排序；（晦涩，意思就是先赋值引用，再调用final值）")])]),a._v(" "),t("p",[a._v("总之上面规则的意思可以这样理解，必需保证一个对象的所有final域被写入完毕后才能引用和读取。这也是内存屏障的起的作用：")]),a._v(" "),t("ul",[t("li",[a._v("写final域：在编译器写final域完毕，构造体结束之前，会插入一个StoreStore屏障，保证前面的对final写入对其他线程/CPU可见，并阻止重排序。")]),a._v(" "),t("li",[a._v("读final域：在上述规则2中，两步操作不能重排序的机理就是在读final域前插入了LoadLoad屏障。\nX86处理器中，由于CPU不会对写-写操作进行重排序，所以StoreStore屏障会被省略；而X86也不会对逻辑上有先后依赖关系的操作进行重排序，所以LoadLoad也会变省略。")])]),a._v(" "),t("blockquote",[t("p",[a._v("volatile和final都使用了内存屏障，只不过volatile有两个保障点，可见性和有序性，可见性是通过缓存锁以及缓存一致性协议控制，有序性是内存屏障来保证。")])])])}),[],!1,null,null,null);r.default=o.exports}}]);