(window.webpackJsonp=window.webpackJsonp||[]).push([[52],{314:function(v,_,e){"use strict";e.r(_);var n=e(17),r=Object(n.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("p",[v._v("jvm比较重要的内存区域"),e("br"),v._v(" "),e("code",[v._v("方法区")]),v._v("：在java的虚拟机中有一块专门用来存放已经加载的类信息、常量、静态变量以及方法代码的内存区域，叫做方法区。"),e("br"),v._v(" "),e("code",[v._v("常量池")]),v._v("：常量池是方法区的一部分，主要用来存放常量和类中的符号引用等信息。"),e("br"),v._v(" "),e("code",[v._v("堆区")]),v._v("：用于存放类的对象实例。"),e("br"),v._v(" "),e("code",[v._v("栈区")]),v._v("：也叫java虚拟机栈，是由一个一个的栈帧组成的后进先出的栈式结构，栈桢中存放方法运行时产生的局部变量、方法出口等信息。当调用一个方法时，虚拟机栈中就会创建一个栈帧存放这些数据，当方法调用完成时，栈帧消失，如果方法中调用了其他方法，则继续在栈顶创建新的栈桢。\n除了以上四个内存区域之外，jvm中的运行时内存区域还包括"),e("code",[v._v("本地方法栈")]),v._v("和"),e("code",[v._v("程序计数器")])]),v._v(" "),e("p",[v._v("1）堆")]),v._v(" "),e("p",[v._v("所有通过new创建的对象的内存都在堆中分配，堆的大小可以通过-Xmx和-Xms来控制。"),e("br"),v._v("\n堆被划分为"),e("code",[v._v("新生代")]),v._v("和"),e("code",[v._v("旧生代")]),v._v("，新生代又被进一步划分为"),e("code",[v._v("Eden")]),v._v("和"),e("code",[v._v("Survivor")]),v._v("区，最后Survivor由From Space和To Space组成")]),v._v(" "),e("p",[e("code",[v._v("新生代")]),v._v("。新建的对象都是用新生代分配内存，Eden空间不足的时候，会把存活的对象转移到Survivor中，\n新生代大小可以由-Xmn来控制，也可以用-XX:SurvivorRatio来控制Eden和Survivor的比例")]),v._v(" "),e("p",[e("code",[v._v("旧生代")]),v._v("。在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。")]),v._v(" "),e("p",[e("code",[v._v("持久代")]),v._v("。已经取消，JDK8 HotSpot JVM现在使用了本地内存来存储类元数据，被称为Metaspace。")]),v._v(" "),e("p",[v._v("2）栈\n每个线程执行每个方法的时候都会在栈中申请一个栈帧，每个栈帧包括局部变量区和操作数栈，用于存放此次方法调用过程中的临时变量、参数和中间结果。")]),v._v(" "),e("p",[v._v("3）本地方法栈\n用于支持native方法的执行，存储了每个native方法调用的状态")]),v._v(" "),e("p",[v._v("4）方法区\n存放了要加载的类信息、静态变量、final类型的常量、属性和方法信息。")]),v._v(" "),e("p",[v._v("基本回收算法")]),v._v(" "),e("ol",[e("li",[v._v("引用计数（Reference Counting）\n比较古老的回收算法。原理是此对象有一个引用，即增加一个计数，删除一个引用则减少一个计数。垃圾回收时，只用收集计数为0的对象。此算法最致命的是无法处理循环引用的问题。")]),v._v(" "),e("li",[v._v("标记-清除（Mark-Sweep）\n此算法执行分两阶段。第一阶段从引用根节点开始标记所有被引用的对象，第二阶段遍历整个堆，把未标记的对象清除。此算法需要暂停整个应用，同时，会产生内存碎片。")]),v._v(" "),e("li",[v._v("复制（Copying）\n此算法把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。次算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不过出现“碎片”问题。当然，此算法的缺点也是很明显的，就是需要两倍内存空间。")]),v._v(" "),e("li",[v._v("标记-整理（Mark-Compact）\n此算法结合了 “标记-清除”和“复制”两个算法的优点。也是分两阶段，第一阶段从根节点开始标记所有被引用对象，第二阶段遍历整个堆，把清除未标记对象并且把存活对象 “压缩”到堆的其中一块，按顺序排放。此算法避免了“标记-清除”的碎片问题，同时也避免了“复制”算法的空间问题。")]),v._v(" "),e("li",[v._v("增量收集（Incremental Collecting）\n实施垃圾回收算法，即：在应用进行的同时进行垃圾回收。不知道什么原因JDK5.0中的收集器没有使用这种算法的。")]),v._v(" "),e("li",[v._v("分代（Generational Collecting）")])]),v._v(" "),e("p",[v._v("垃圾收集器\n串行GC（Serial GC）、并行回收GC（Parallel Scavenge）和并发回收GC（ParNew）")]),v._v(" "),e("p",[v._v("GC有两种类型："),e("code",[v._v("Scavenge GC")]),v._v("和"),e("code",[v._v("Full GC")]),v._v("。\nJVM分别对新生代和旧生代采用不同的垃圾回收机制")]),v._v(" "),e("p",[v._v("JVM内存调优\n使用JDK提供的内存查看工具，比如JConsole和Java VisualVM。")]),v._v(" "),e("p",[v._v("首先需要注意的是在对JVM内存调优的时候不能只看操作系统级别Java进程所占用的内存，这个数值不能准确的反应堆内存的真实占用情况，因为GC过后这个值是不会变化的，因此内存调优的时候要更多地使用JDK提供的内存查看工具，比如JConsole和Java VisualVM。")]),v._v(" "),e("pre",[e("code",[v._v("对JVM内存的系统级的调优主要的目的是减少GC的频率和Full GC的次数，过多的GC和Full GC是会占用很多的系统资源（主要是CPU），影响系统的吞吐量。特别要关注Full GC，因为它会对整个堆进行整理，导致Full GC一般由于以下几种情况：\n")])]),v._v(" "),e("p",[v._v("旧生代空间不足\n调优时尽量让对象在新生代GC时被回收、让对象在新生代多存活一段时间和不要创建过大的对象及数组避免直接在旧生代创建对象")]),v._v(" "),e("p",[v._v("Pemanet Generation空间不足\n增大Perm Gen空间，避免太多静态对象")]),v._v(" "),e("pre",[e("code",[v._v("统计得到的GC后晋升到旧生代的平均大小大于旧生代剩余空间\n控制好新生代和旧生代的比例 \n")])]),v._v(" "),e("p",[v._v("System.gc()被显示调用\n垃圾回收不要手动触发，尽量依靠JVM自身的机制")]),v._v(" "),e("pre",[e("code",[v._v("调优手段主要是通过控制堆内存的各个部分的比例和GC策略来实现，下面来看看各部分比例不良设置会导致什么后果\n")])]),v._v(" "),e("p",[v._v("1）新生代设置过小")]),v._v(" "),e("pre",[e("code",[v._v("一是新生代GC次数非常频繁，增大系统消耗；二是导致大对象直接进入旧生代，占据了旧生代剩余空间，诱发Full GC\n")])]),v._v(" "),e("p",[v._v("2）新生代设置过大")]),v._v(" "),e("pre",[e("code",[v._v("一是新生代设置过大会导致旧生代过小（堆总量一定），从而诱发Full GC；二是新生代GC耗时大幅度增加\n\n一般说来新生代占整个堆1/3比较合适\n")])]),v._v(" "),e("p",[v._v("3）Survivor设置过小")]),v._v(" "),e("pre",[e("code",[v._v("导致对象从eden直接到达旧生代，降低了在新生代的存活时间\n")])]),v._v(" "),e("p",[v._v("4）Survivor设置过大")]),v._v(" "),e("pre",[e("code",[v._v("导致eden过小，增加了GC频率\n\n另外，通过-XX:MaxTenuringThreshold=n来控制新生代存活时间，尽量让对象在新生代被回收\n\n由内存管理和垃圾回收可知新生代和旧生代都有多种GC策略和组合搭配，选择这些策略对于我们这些开发人员是个难题，JVM提供两种较为简单的GC策略的设置方式\n")])]),v._v(" "),e("p",[v._v("1）吞吐量优先")]),v._v(" "),e("pre",[e("code",[v._v("JVM以吞吐量为指标，自行选择相应的GC策略及控制新生代与旧生代的大小比例，来达到吞吐量指标。这个值可由-XX:GCTimeRatio=n来设置\n")])]),v._v(" "),e("p",[v._v("2）暂停时间优先")]),v._v(" "),e("pre",[e("code",[v._v("JVM以暂停时间为指标，自行选择相应的GC策略及控制新生代与旧生代的大小比例，尽量保证每次GC造成的应用停止时间都在指定的数值范围内完成。这个值可由-XX:MaxGCPauseRatio=n来设置\n")])]),v._v(" "),e("p",[v._v("最后汇总一下JVM常见配置")]),v._v(" "),e("p",[v._v("堆设置")]),v._v(" "),e("p",[v._v("-Xms:初始堆大小")]),v._v(" "),e("p",[v._v("-Xmx:最大堆大小")]),v._v(" "),e("p",[v._v("-XX:NewSize=n:设置年轻代大小")]),v._v(" "),e("p",[v._v("-XX:NewRatio=n:设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4")]),v._v(" "),e("p",[v._v("-XX:SurvivorRatio=n:年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor=3：2，一个Survivor区占整个年轻代的1/5")]),v._v(" "),e("p",[v._v("-XX:MaxPermSize=n:设置持久代大小")]),v._v(" "),e("p",[v._v("收集器设置")]),v._v(" "),e("p",[v._v("-XX:+UseSerialGC:设置串行收集器")]),v._v(" "),e("p",[v._v("-XX:+UseParallelGC:设置并行收集器")]),v._v(" "),e("p",[v._v("-XX:+UseParalledlOldGC:设置并行年老代收集器")]),v._v(" "),e("p",[v._v("-XX:+UseConcMarkSweepGC:设置并发收集器")]),v._v(" "),e("p",[v._v("垃圾回收统计信息")]),v._v(" "),e("p",[v._v("-XX:+PrintGC")]),v._v(" "),e("p",[v._v("-XX:+PrintGCDetails")]),v._v(" "),e("p",[v._v("-XX:+PrintGCTimeStamps")]),v._v(" "),e("p",[v._v("-Xloggc:filename")]),v._v(" "),e("p",[v._v("并行收集器设置")]),v._v(" "),e("p",[v._v("-XX:ParallelGCThreads=n:设置并行收集器收集时使用的CPU数。并行收集线程数。")]),v._v(" "),e("p",[v._v("-XX:MaxGCPauseMillis=n:设置并行收集最大暂停时间")]),v._v(" "),e("p",[v._v("-XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+n)")]),v._v(" "),e("p",[v._v("并发收集器设置")]),v._v(" "),e("p",[v._v("-XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况。")]),v._v(" "),e("p",[v._v("-XX:ParallelGCThreads=n:设置并发收集器年轻代收集方式为并行收集时，使用的CPU数。并行收集线程数。")])])}),[],!1,null,null,null);_.default=r.exports}}]);